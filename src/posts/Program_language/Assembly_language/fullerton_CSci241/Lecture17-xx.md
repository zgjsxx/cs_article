---
category: 
- 汇编语言
---

# 第十七讲：Z80汇编语言(任天堂游戏机和德州仪器计算器)

## 寄存器

Z80 有 8 个或 5 个通用寄存器，具体取决于您如何看待事物：
- 寄存器 ```A```、```F```、```B```、```C```、```D```、```E```、```H``` 和 ```L``` 可以单独用作 8 位寄存器
- 寄存器对```BC```、```DE```和```HL```可用作16位寄存器，其中```B```是 ```BC``` 的高字节，而 ```C``` 是低字节。
- 有点奇怪的是，```A``` 寄存器可以与标志寄存器 ```F``` 组合起来作为 16 位寄存器 ```AF```。
- 寄存器 ```IX``` 和 ```IY``` 是 16 位索引寄存器，与内存操作数一起使用。 ```HL``` 类似地用于内存操作数。

与 ```x86``` 一样，```SP``` 寄存器指向堆栈顶部，```PC``` 寄存器指向当前指令（请注意，这与 x86 的 IP 寄存器指向下一条指令不同）。```F```寄存器包含标志：符号、零、奇偶校验/溢出、满进位。```A``` 和 ```F``` 寄存器可以通过几条指令组合成一个 16 位寄存器 ```AF```。

Z80有一个中断向量寄存器I，其中包含中断向量表的地址，这个设计很有先见之明；在这个时代的Intel CPU中，中断向量的地址是固定在内存中的。

与 x86 不同，Z80 有一组影子寄存器；这是一组附加寄存器 ```A'```、```F'```、```B'```、```C'```、```D'```、```E'```、```H'``` 和 ```L'```。

您无法直接访问这些寄存器，但可以使用一条指令交换主寄存器组和影子寄存器组。

这提供了一种简单但有限的方法来保存所有寄存器的值，然后在以后恢复它们（但是，与堆栈不同，您只能保存一组寄存器值）。

## 指令集

大多数 Z80 汇编器使用的语法更像 AT&T 语法而不是 Intel 语法。这意味着指令具有以下形式

```x86asm
   INSTRUCTION DESTINATION, SOURCE
```

内存的操作写在括号中。

你可以在这里查找到完整的Z80指令集： [Z80指令集](https://www.ticalc.org/pub/text/z80/z80_reference.txt)

```mov``` 已重命名为 ```ld```（"加载"），但它可用于将值写入寄存器或内存。例如:

```x86asm
    ld  a, 5             ; Set register A = 5
    ld  b, 7             ; Set register B = 7
    add a, b             ; Set A = A + B
    ld [Output], a       ; Write A into address Output
```

（一些 Z80 汇编器将内存操作数写在括号 () 中，而其他汇编器（例如我们将要使用的汇编器）则使用更熟悉的 [])。

```add``` 指令只能使用 ```a```、```hl```、```ix``` 或 ```iy``` 作为其目标。内存操作数可以使用立即地址，或者您可以执行类似的操作

```X86asm
ld [hl], a ; Write A into the address contained in HL
```

如果要在内存操作数中使用立即地址加寄存器，则寄存器必须是 ```IX``` 或 ```IY```：

```x86asm
ld [Array + ix], a   ; Write A into Array[ix]
```

与 x86 一样，```ld``` 的两个操作数必须具有相同的大小：均为 8 位或均为 16 位。根据需要，立即操作数将提升为 16 位。

Z80 指令的大小为 1 到 3 个字节。

## 条件跳转

有两种条件跳转指令：

```x86asm
    jp CC, Target           ; 条件绝对跳转

    jr CC, Target           ; 条件相对跳转
```

其中 CC 是条件代码。两者的主要区别是```jp```更灵活（可以使用更多条件，速度更快），而```jr```更有限（条件更少，速度更慢，只能在程序内跳转±128字节）但只占用2个字节程序而不是 ```jp``` 的 3 个字节。

更专门的条件跳转指令是 ```djnz```，类似于 x86 中的```loop```，它代表"递减，如果非零则跳转"

```x86asm
 djnz Target          ; Decrement B, jump to Target if B ≠ 0
```

## 函数

```call```与 x86 一样，用于调用函数，它压入 ```PC+3```，然后跳转到函数地址。 （请记住，```PC``` 包含当前指令的地址；即 ```call``` 指令本身。```call``` 指令占用 3 个字节，因此下一条指令是 ```PC+3```。）类似地，```ret``` 通过弹出 ```PC``` 和跳向它。

与 x86 不同，Z80 有条件返回指令：

```x86asm
ret p               ; Return if positive (sign flag = 0)
```

可用条件有 C/NC（进位设置/未设置）、M/P（符号 = 1/0）、Z/NZ（零 = 1/0）、PE/PO（奇偶校验 = 1/2）。这些与条件跳转指令 jp CC 所使用的条件相同.

```push``` 和 ```pop``` 可用于将寄存器压入堆栈或从堆栈中弹出。只有16位寄存器可以压入/弹出，所以如果你想压入A，你必须结合标志寄存器来压入它：

```x86asm
 push af
```

## 块传输