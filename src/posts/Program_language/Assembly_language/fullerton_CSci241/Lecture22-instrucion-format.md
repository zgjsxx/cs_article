---
category: 
- 汇编语言
---

- [第二十二讲 指令格式](#第二十二讲-指令格式)
  - [MIPS32指令格式](#mips32指令格式)
    - [R(Register)指令格式](#rregister指令格式)
    - [I(Imediate)指令格式](#iimediate指令格式)
    - [J(jump)指令格式](#jjump指令格式)
    - [例子](#例子)
  - [x86-64操作码的格式](#x86-64操作码的格式)
    - [前缀](#前缀)
  - [附录](#附录)


# 第二十二讲 指令格式

## MIPS32指令格式

我们先前研究指令流水线是提到过**MIPS32**。**MIPS32**使用固定长度的指令，即每个指令32位。**MIPS32**存在三种不同的指令格式，但这三种指令格式都使用高6位作为操作码。

### R(Register)指令格式

R指令格式具有三个寄存器的字段（通常为两个源寄存器和一个目标寄存器），以及移位量（5 位）和函数（6 位）。R指令格式用于没有立即数的算术运算或者位运算。所有的R指令的Opcode都是全0。

|Opcode = 000000|RS|RT|RD|Sh.Amount|Function|
|--|--|--|--|--|--|
|6bits|5|5|5|5|6|

**函数字段**指定了要应用于 RS、RT（源）和 RD（目标）的实际算术函数。例如，函数字段 32 (```100000b```) 是加法。左/右移位指令使用移位量字段来指定要移位的量。下表给出了更多的例子：

|指令名|格式|op|rs|rt|rd|sh amt|func|example|
|--|--|--|--|--|--|--|--|--|
|add|R|0|2|3|1|0|32|add $1, $2, $3|
|addu|R|0|2|3|1|0|33|addu $1, $2, $3|
|sub|R|0|2|3|1|0|34|sub $1, $2, $3|
|subu|R|0|2|3|1|0|35|subu $1, $2, $3|
|and|R|0|2|3|1|0|36|and $1, $2, $3|
|or|R|0|2|3|1|0|37|or $1, $2, $3|
|nor|R|0|2|3|1|0|39|nor $1, $2, $3|
|slt|R|0|2|3|1|0|42|slt $1, $2, $3|
|sltu|R|0|2|3|1|0|43|sltu $1, $2, $3|
### I(Imediate)指令格式

I指令格式包含两个寄存器字段（通常是源寄存器和目标寄存器）和 16位立即数字段。 I格式用于带有立即数的算术运算，也用于使用基址+位移寻址方案的内存加载/存储指令（位移存储在立即数字段中，并且仅限于 16 位，有符号）

|Opcode|RS|RD|Immediate/Address|
|--|--|--|--|
|6bits|5bits|5bits|16bits|

MIPS有32个寄存器(${2}^{5}$),因此使用5个比特位就可以进行编码表示， 所以RS/RT各为5个比特。立即数字段使用任何16位立即值进行填充。


### J(jump)指令格式

J指令格式用于跳转指令，跳转到绝对地址。其中目标地址为26位，由于MIPS的地址是32位对齐的，因此其地址的低2位固定为零。这样已经构成了28位地址。缺失剩下的4个位，由PC指针的高4位提供。

$$实际的跳转地址 = PC指针的高4位 + 26位伪地址 + 2个0位$$

|操作码|伪地址|
|--|--|
|6比特|26比特|

J格式合法的操作码是```0x2```和```0x3```。

### 例子

这里我们看一下MIPS指令的一些示例并对其进行解码。

**例1**：

```shell
00000000001000100001100000100000 = 0x00221820
```

因为高6位是 0，这是一个算术运算，是R指令格式，所以我们将指令分解为:

|000000|00001|00010|00011|00000|100000|
|--|--|--|--|--|--|
|Opcode|Rs|Rt|Rd|sh.amt|Operation|

两个源寄存器是r1和r2；目标寄存器是r3 该操作是32，对应于add指令，因此解码为```add r3, r1, r2```

**例2**：

```shell
00001000110110101100010000100110
```

操作码（高6位）为2，表示跳转指令，因此上述指令可以解码为：

|000010|00110110101100010000100110|
|--|--|
|操作码|地址|

这对应于地址为 ```0xDAC426``` 的跳转（该地址将使用指令指针的当前内容扩展为 32 位）。

**例3**：

```shell
001000 00001 00010 0000000000100101
```

操作码是8，它既不是R指令也不是J指令，所以它就是I格式：

|001000|00001|00010|0000000000100101|
|--|--|--|--|
|操作码|Rs|Rd|立即数|


```x86asm
addi r2, r1, 37
```

## x86-64操作码的格式

x86架构的指令格式在intel的手册中可以查到：[intel手册](https://www.intel.cn/content/www/cn/zh/content-details/782158/intel-64-and-ia-32-architectures-software-developer-s-manual-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html)

基本指令格式如下：

|Field|Prefixes|Opcode|ModR/M|SIB|Displacement|Immediate|
|--|--|--|--|--|--|--|
|size(bytes)|1-4|1,2,3|0,1|0,1|0,1,2,4,8|0,1,2,4,8|

最大指令大小限制为 15 个字节。构建比这更大的理论指令是可能的，但它们是非法的。请注意，一些指令允许 8 字节立即数或 8 字节地址，但显然不能同时使用两者。有四组前缀 1-4，并且每组只能出现一个前缀。这些组可以按任何顺序给出，但 REX 前缀（如果存在）必须是最后一个前缀（即，应紧接在操作码之前）。因为所有 64 位指令都使用 REX 前缀，这意味着我们使用的每条指令都至少包含 REX 后跟操作码。

某些前缀对于某些指令是强制性的，表明这些指令必须存在前缀字节，尽管它没有其正常含义。当存在强制前缀时，它必须紧邻操作码之前（或者，如果使用，则放在 REX 前缀之前）。强制前缀通常用于通过将现有操作码用于不同目的来“扩展”可用操作码的空间。

前缀组是：
- 锁定和重复前缀。锁定用于指示应以原子方式执行指令。重复前缀的值为 0xF2 (repne) 和 0xF3 (repe/rep)。对于一些不相关的指令来说，这些前缀是必需的。
- 段覆盖前缀。这些前缀指示指令应使用与其正常解释不同的段寄存器（如果启用了分段）。
- 操作数大小覆盖，编码为 0x66。这会在 16 位（默认）和 32 位（如果使用前缀）大小的操作数之间切换。某些 SSE 指令是强制性的。
- 地址大小覆盖，编码为 0x67。在 16 位和 32 位地址大小之间切换。默认值由当前处理器模式设置；如果存在前缀，则选择非默认大小。


### 前缀

前缀用于修改指令。例如，重复前缀```rep```、```repne```和```repe```都是前缀。他们适用于现有的字符串指令。



## 附录

MIPS指令格式：

http://www.cs.kzoo.edu/cs230/Resources/MIPS/MachineXL/InstructionFormats.html
https://en.wikibooks.org/wiki/MIPS_Assembly/Instruction_Formats#J_Format

https://staffwww.fullcoll.edu/aclifton/cs241/lecture-instruction-format.html