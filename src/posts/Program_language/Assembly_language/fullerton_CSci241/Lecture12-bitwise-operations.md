---
category: 
- 汇编语言
---

# 第十二讲：按位运算

## 按位运算

位运算在汇编语言中很重要。我们已经学习了```xor```（异或），这里我们将学习其他操作```or```、```and```、```not```、```andn```（与非），以及**移位**和**旋转**操作。除了这些在 C/C++ 也有的位运算之外，汇编语言还支持 C/C++ 语言没有的一些位运算。```test```操作是按位进行比较的运算符，在条件跳转时可能会用它来构建跳转的状态位。

### AND，OR，NOT，AND-NOT位运算

```x86asm
not  dest         ; dest = ~dest
and  dest, src    ; dest = dest & src
or   dest, src    ; dest = dest | src
andn dest, src    ; dest = dest & ~src
xor  dest, src    ; dest = dest ^ src
```

上面的指令通常的限制如下：
- 两个操作数必须具有相同的大小，```dest```和```src```不能都在内存中，并且只有源操作数(```src```)可以是立即数。
- ```not``` 可以与寄存器或内存位置一起使用。

这些操作的真值表如下所示：
- 如果 a 为 0，则 ~a 为 1；如果 a 为 1，则 ~a 为 0：
  |a| ~a|
  |--|--|
  |0|1|
  |1|0|
- 只有当a和b都为1时a和b才为1，否则为0。
  |a| b| a & b|
  |--|--|--|
  |0|0|0|
  |1|0|0|
  |0|1|0|
  |1|1|1|
- 如果 a 或 b 为 1，则 a | b 为 1；只有当 a 或 b 均为 0 时，a | b 才为 0。
  |a|b| a or b| 
  |--|--|--|
  |0|0|0|
  |1|0|1|
  |0|1|1|
  |1|1|1|

- ```a&~b```，只有当a = 1且b = 0时， 结果才为1。
  |a|b| a & ~b| 
  |--|--|--|
  |0|0|0|
  |1|0|1|
  |0|1|0|
  |1|1|0|

- ```a^b```，当a和b有一个值为1时，结果为1。
  |a|b| a ^ b| 
  |--|--|--|
  |0|0|0|
  |1|0|1|
  |0|1|1|
  |1|1|0|


真值表反应的是单个比特位运算的计算方法。当应用于二进制数字，则将每个比特位执行相应的运算。例如：

```shell
   01101101
 & 11101110
------------ 
   01101100
```

### 设置/取消比特位， 翻转比特位

对一个比特位的常见操作有三种:
- 设置比特位(设置值为1)
- 取消比特位(设置值为0)
- 翻转比特位(原值为0，设置为1，原值为1，设置为0)

这些操作的第一个步骤是构造一个位掩码，我们希望操作的位的值为 1，其他位置的值为 0。

```x86asm
bitmask:   EQU   10000000b    ; Manipulate bit 7
```

如果位置不是恒定的，那么我们可以使用移位（见下文）来动态构造掩码。

要设置一个位，同时保持所有其他位不变，我们使用```or```。 ```x or 0 == x```，因此掩码中未设置的位将保持不变，但 ```x or 1 == 1```，因此掩码中已设置的位将被强制为 1。

```x86asm
or  rax, bitmask 
```

为了取消比特位，我们需要一个按位运算 OP，它满足 ```x OP 0 == x``` 和 ```x OP 1 == 0```。查看上面的真值表，我们发现与非运算就是我们想要的。

```x86asm
andn rax, bitmask
```

为了翻转一个比特位，我们需要一个操作 ```OP```，其中 ```x OP 0 == x``` 但 ```x OP 1 == ~x```。同样，从表中我们可以看到 ```xor``` 就是我们想要的：

```x868asm
xor rax, bitmask
```

如果需要一次性操作多个比特位，则需要一个设置了多个位的掩码，这样就可以一次性设置/清除/翻转多个位。

## 符号位的延伸

上面，汇编器负责将位掩码的值扩展为 64 位（```rax``` 的大小），以便大小匹配。实际上，位运算可以用在长度小于目标的立即数与目标数上。我们可以通过为立即数掩码显式指定大小来强制执行此行为：

```x86asm
mov rax, 0
or  rax, byte bitmask ; What bit(s) does this set?
```

当立即数的值（显式）小于目标值时，将符号扩展为目标值的大小。

现在我们想将其扩展到 16 位。如果我们简单地添加 0，那么我们有

```shell
0000000011111111b = 127 (!)
```

请记住，如果未设置高位，则该值为正！相反，我们将 11111111b 的最高位复制到我们添加的新位中：

```shell
1111111111111111b = -1
```

每当我们扩展一个有符号值时，我们都需要执行符号扩展。相反，如果我们扩展一个无符号值，那么我们一定不能执行符号扩展，因为它会给出错误的结果。为了扩展无符号值，我们执行零扩展，用零填充高位。

这两种转换的区别就是 ```movsx``` 和 ```movzx``` 操作的区别：

```x86asm
movsx dest, src      ; Sign-extend src into dest
movzx dest, src      ; Zero-extent src into dest
```

## 移位和旋转

在 C/C++ 中，我们有 ```<<``` 和 ```>>``` 运算符，它们执行**左移位**和**右移位**。它们通常用作乘/除2的便捷方式。要了解其原理，请考虑二进制值 3：


## 附录

原文连接：https://staffwww.fullcoll.edu/aclifton/cs241/lecture-bitwise-operations.html