---
category: 
- 汇编语言
---

# 第三讲：数字表示

```x86asm
;;; 
;;; hello.s
;;; Prints "Hello, world!"
;;;

section .data

msg:            db      "Hello, world!", 10
MSGLEN:         equ     $-msg

section .text

;; Program code goes here

global _start
_start:

    mov     rax,    1               ; Syscall code in rax
    mov     rdi,    1               ; 1st arg, file desc. to write to
    mov     rsi,    msg             ; 2nd arg, addr. of message
    mov     rdx,    MSGLEN          ; 3rd arg, num. of chars to print
    syscall

    ;; Terminate process
    mov     rax,    60              ; Syscall code in rax
    mov     rdi,    0               ; First parameter in rdi
    syscall                         ; End process
```

我们可以进行汇编和连接。

```shell
asm hello.s
```

或者可以进行手动编译连接：

```shell
yasm -g dwarf2 -f elf64 hello.s -l hello.lst
ld -g -o hello hello.o
```

然后通过下面的命令执行：

```shel
./hello
```

这一讲的内容将涵盖不同数字表示形式之间的转换、通用寄存器、附加专用寄存器。并且会以一个课堂项目小组项目结束。

## 操作数

每条汇编指令都有许多"操作数"。最大的指令有三个操作数，大多数有两个或一个，有些（如系统调用）没有操作数。每个操作数可以是以下内容之一（有一些限制，具体取决于具体指令）。

- register的名字，例如```rax```。
- 一个常量，例如 60 或 msg。(msg作为一个标签，其实也是一个常量。汇编器计算字符串的首地址，并将实际数值写入指令中)。常量操作数在汇编语言术语中称为立即数。
  请注意，由于汇编器可以进行算术运算，因此形如```4 * msg + 1```这样的立即数，它的值在汇编阶段也是已知的。（你不能做像 rax + 1 这样的事情，因为寄存器 rax 的值在程序运行之前是不知道的。）
- 内存直接查找。[msg] 给出内存中地址 msg 处的值。即，这将给出字符串的前 8 个字节，作为 qword 值。
- 内存间接查找。```[rax]```可以给出一个内存中的值。该值的地址存储在rax寄存器中。有几种不同形式的内存间接操作数，它们允许以自然的方式访问数组和结构。我们稍后会看看这些。

通常, 当我们使用一个内存操作时，我们需要给出一个尺寸限定符， 例如 ```byte [msg]```，代表msg位置的第一个字节，```qword [rax]```代表rax指向的内存地址出的8个bytes的内容。尺寸限定符通常是可选的，因为它可以从其他操作数中推断出来。不过在实际中，总是添加尺寸限定符是一个很好的习惯， 这会帮助找到尺寸不匹配的错误。

通常，内存操作数被分组在一起，一般来说，只要允许内存直接操作数，也允许内存间接操作数。因此我们可以通过R(register)， I(Immediate)和 M（memory）的组合来描述允许的操作符的类型。如果我们说给定的操作数是 ```RM```，则意味着它支持寄存器和内存操作数，但不支持立即数。

大多数指令都有以下限制：

- 对于双操作数指令，两者的大小必须相同。 （有专门的指令用于在不同大小的操作数之间进行转换。）某些指令仅对特定大小进行操作。
- 许多指令只能读取小于 qword 的内存值。 mov 和其他一些指令是唯一支持访问 ```qword [addr]``` 的指令。
- 仅 mov 支持 64 位立即数。
- 一条指令中的两个操作数不能都是内存。
- 目标操作数不能是立即数。

## 数字的表示

尽管我们都熟悉数字的十进制表示形式，但回顾一下它的工作原理可能会有所帮助：假设我们有一个十进制数，例如 15386。该数字的数值由下式给出

$$6({10}_{0}) + 8({10}_{1} + 3({10}_{2}) + 5({10}_{3}) + 1({10}_{4}))$$

换句话说，为了计算一个数字的值，我们从第一个数字(最右边的数字)开始， 每一个位置的数字乘以10的这个位置的次方， 再进行求和，即可。使用10的原因是每个位置的可能的值是0，1，2……8, 9。

其他系统基本上以相同的方式工作，唯一改变的是每个数字有多少个可能的值：

- 对于二进制而言，只有2种选择， 0或者1。所以二进制的基数是2。
- 对于十六进制而言， 有16种类选择，0，1，2，……8，9，a,b …… e,f。因此十六进制的基数是16。
- 对于八进制而言，有8种选择， 0，1，2，……6，7,所以八进制的基数是8。
  
### 其他进制转换为10进制

将一个二进制数```1001011b```转换为十进制，我们这样计算：

$$1({2}_{0}) + 1({2}_{1} + 0({2}_{2}) + 1({2}_{3}) + 0({2}_{4}) + 0({2}_{5}) + 1({2}_{6}) = 75)$$

将一个十六进制数```0x1a2b```转换为十进制，我们这样计算：

$$11({16}_{0}) + 2({16}_{1} + 10({16}_{2}) + 1({16}_{3}) = 6699)$$

八进制也是类似的。八进制平常使用很少，这里不再讲解。

### 10进制转换为其他进制

将十进制值转换为二进制或十六进制有点棘手。我们将以二进制形式查看该过程，这并不是太困难，然后将其推广为十六进制。

要将十进制值（例如 1234）转换为二进制，我们除以 2，然后查看余数：0。这成为低位，我们使用该值除以 2 并向下舍入（即 617），作为下一阶段的输入：

```shell
xxxxxxxxxx0
```

我们再次将 617 除以 2 并查看余数。它是 1，所以我们将下一个较高位设置为 1，并使用 617/2 = 308 作为下一个周期的输入：

```shell
xxxxxxxxx10
```

继续这个过程我们得到：

|输入|余数|二进制数|
|--|--|--|
|1234|	0|	__________0|
|617|	1|	_________10|
|308|	0|	________010|
|154|	0|	_______0010|
|77	|1|	______10010|
|38	|0|	_____010010|
|19	|1|	____1010010|
|9	|1|	___11010010|
|4	|0|	__011010010|
|2	|0|	_0011010010|
|1	|1|	10011010010|

由于$1/2 = 0$， 我们可以停止计算。如果需要，我们可以通过将二进制值转换回十进制来验证我们的工作。

类似的过程可用于将十进制转换为十六进制，只不过我们除以 16。例如，将 1234 转换为十六进制：

|输入|余数|二进制数|
|--|--|--|
|1234|2|	0x___2|
|77|	13 = d|	0x__d2|
|4|	4	|0x4d2|

每次除以 16 显然比除以 2 更快地得到 0。

## 二进制算术

### 无符号二进制加法

无符号二进制加法（即两个正数）的工作方式类似于正常的十进制数的加法，只是只有两个数字，因此1 + 1 = 10，进位为1。例如：

```shell
    1001011
 +  1100101
────────────
```

1+1=10，所以我们把0添加到结果中，然后将1添加到进位中。

```shell
         1
    1001011
 +  1100101
────────────
          0
```

接着由于1+1=10， 我们在将0放入结果，把1放入进位中：

```shell
        11
    1001011
 +  1100101
────────────
         00
```

再一次由于1+1=10， 我们在将0放入结果，把1放入进位中：

```shell
       111
    1001011
 +  1100101
────────────
        000
```

再一次计算：

```shell
      1111
    1001011
 +  1100101
────────────
       0000
```

1 + 0 + 0 = 1，所以不需要进位：

```shell
      1111
    1001011
 +  1100101
────────────
      10000
```

0 + 1 = 1:

```shell
      1111
    1001011
 +  1100101
────────────
     110000
```

最后 1 + 1 = 10，进位的 1 落入结果中：

```shell
      1111
    1001011
 +  1100101
────────────
   10110000
```

检验一下我们的工作，两个加数分别是75和101，答案应该是176,是正确的。

这个例子也说明了有时会出现的一个问题：两个n位值相加的结果可能有n+1位。例如，如果我们添加两个字节，结果可能无法容纳一个字节！我们稍后会看到 CPU 如何处理这种情况。

```shell
   111111
   01011011  = 91
 + 01110110  = 118
────────────
   11010001  = 209
```

### 无符号数字的减法

减法遵循类似的模式，但用"借"而不是进位。例如：
```shell
    110110
 -  100001
────────────
```
- 1 = -1，所以我们从下一列借用 1（即，我们正在执行 10 - 1 = 1）

```shell
    110102
 -  100001
────────────
         1
```

## 寄存器和内存

寄存器占据内存层次结构的最高层。它们位于 CPU 本身上，可以通过指令直接访问，因此是存储您正在使用的值的最快位置。另一方面，由于它们在物理上必须靠近CPU，因此不能占用太多空间；x86-64有16个64位通用寄存器，16个128位浮点/SIMD寄存器，以及一些特殊用途寄存器。


### 通用寄存器

通用寄存器的排列方式是将全部 64 位划分为低 32 位、低 16 位和低（有时是高）8 位。例如，对于 rax：


只有寄存器 rax、rbx、rcx 和 rdx 允许通过 ah、bh、ch 和 dh 访问高字节（低字，因此它实际上位于整个寄存器的中间）。使用它们的时间/地点有一些限制（在 64 位模式下）。


|64-bits| 低32bits| 低16bits| 低8bits| 描述| 
|--|--|--|--|--|
|rax|eax|ax|al|系统调用的操作码和返回值，累加器|
|rbx|ebx|bx|bl|基址寄存器|
|rcx|ecx|cx|cl|循环计数， 系统调用临时寄存器|
|rdx|edx|dx|dl|系统调用的第三个参数|


当我们讨论函数时，我们会看到每个寄存器都属于一个额外的分类：

当我们调用一个函数时，我们是函数调用者负责在需要时保存寄存器（“被调用者保留的寄存器”），还是我们调用的函数负责在需要时保存寄存器（“调用者”） -保留的寄存器”）？

```rsp```和```rbp```虽然是通用寄存器，但是通常用于管理栈。```rsp```指向栈顶，而``` rbp```（基指寄存器）传统上指向当前函数堆栈帧的开头。rsp 不应用于其他用途，但 rbp 并非严格禁止使用。请注意，```rsp``` 指向栈顶部的元素，而不是其上方的空白空间。

```rax``` 称为累加器，并且一些指令隐式地使用它作为目的地。同样，rbx 有时称为“基址”寄存器，rcx 称为“计数寄存器”，rdx 称为“双字累加器”


### mov指令

汇编语言最基本的指令就是```mov```， 它将数据从一个位置移动(内存、寄存器、理解数)到另一个位置(内存、寄存器)。它具有一下的形式：

```x86asm
mov destination, source
```
其中目的操作数可以是寄存器或内存，源操作数可以是寄存器、内存或立即值。

目的操作数和源操作数的大小必须相同，并且源操作数和目的操作数不能同为内存类型。

```x86asm
add rax, some_huge_constant
```


```x86asm
mov rbx, some_huge_constant
add rax, rbx
```


### 交换寄存器的值

```x86asm
xchg a, b
```

### 清除寄存器

```x86asm
mov reg, 0
```

```x86asm
xor reg, reg
```


## 特殊用途的寄存器

以下寄存器用于特定目的，由 CPU 强制执行。您要么无法将一般数据放入其中，要么无法从中取出数据。通常必须使用专门的指令（不是 mov）来访问它们。
- rip 指令指针指向下一条要执行的指令（即紧接在这条指令之后的指令）。低 32 位可作为 eip 访问，低位字可作为 ip 访问，但由于地址始终是 64 位，因此这并不是特别有用。分支指令直接修改rip。
- rflags寄存器：标志寄存器的每一位都有不同的含义，并且根据某些操作的结果设置或取消设置各种标志。当我们了解测试和条件操作时，我们将深入研究标志寄存器。通常你不需要担心访问标志寄存器，因为它是由相关操作自动设置和测试的。