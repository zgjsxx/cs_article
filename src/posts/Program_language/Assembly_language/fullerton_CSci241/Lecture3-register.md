---
category: 
- 汇编语言
---

# 第三讲：数字表示

```x86asm
;;; 
;;; hello.s
;;; Prints "Hello, world!"
;;;

section .data

msg:            db      "Hello, world!", 10
MSGLEN:         equ     $-msg

section .text

;; Program code goes here

global _start
_start:

    mov     rax,    1               ; Syscall code in rax
    mov     rdi,    1               ; 1st arg, file desc. to write to
    mov     rsi,    msg             ; 2nd arg, addr. of message
    mov     rdx,    MSGLEN          ; 3rd arg, num. of chars to print
    syscall

    ;; Terminate process
    mov     rax,    60              ; Syscall code in rax
    mov     rdi,    0               ; First parameter in rdi
    syscall                         ; End process
```

我们可以进行汇编和连接。

```shell
asm hello.s
```

或者可以进行手动编译连接：
```shell
yasm -g dwarf2 -f elf64 hello.s -l hello.lst
ld -g -o hello hello.o
```

## 操作数

每条汇编指令都有许多"操作数"。最大的指令有三个操作数，大多数有两个或一个，有些（如系统调用）没有。每个操作数可以是以下内容之一（有一些限制，具体取决于具体指令）。

- register的名字，例如```rax```。
- 一个常量，例如 60 或 msg。
- 内存直接查找。
- 内存间接查找。```[rax]```可以给出一个内存中的值。该值的地址存储在rax寄存器中。有几种不同形式的内存间接操作数，它们允许以自然的方式访问数组和结构。我们稍后会看看这些。

通常, 当我们使用一个内存操作时，我们需要给出一个尺寸限定符， 例如 ```byte [msg]```，代表msg位置的第一个字节，```qword [rax]```代表rax指向的内存地址出的8个bytes的内容。尺寸限定符通常是可选的，因为它可以从其他操作数中推断出来。不过在实际中，总是添加尺寸限定符是一个很好的习惯， 这会帮助找到尺寸不匹配的错误。

如果我们说给定的操作数是 ```RM```，则意味着它支持寄存器和内存操作数，但不支持立即数。

大多数指令都有以下限制：

- 对于双操作数指令，两者的大小必须相同。 （有专门的指令用于在不同大小的操作数之间进行转换。）某些指令仅对特定大小进行操作。
- 许多指令只能读取小于 qword 的内存值。 mov 和其他一些指令是唯一支持访问 qword [addr] 的指令。
- 仅 mov 支持 64 位立即数。
- 两个操作数不能在一条指令中都是内存
- 目标操作数不能是立即数（显然）。

## 数字的表示

尽管我们都熟悉数字的十进制表示形式，但回顾一下它的工作原理可能会有所帮助：假设我们有一个十进制数，例如 15386。该数字的数值由下式给出

$$6({10}_{0}) + 8({10}_{1} + 3({10}_{2}) + 5({10}_{3}) + 1({10}_{4}))$$

换句话说


## 转换为10进制

将一个二进制数```1001011b```转换为十进制，我们这样计算：

$$1({2}_{0}) + 1({2}_{1} + 0({2}_{2}) + 1({2}_{3}) + 0({2}_{4}) + 0({2}_{5}) + 1({2}_{6}) = 75)$$

将一个十六进制数```0x1a2b```转换为十进制，我们这样计算：

$$11({16}_{0}) + 2({16}_{1} + 10({16}_{2}) + 1({16}_{3}) = 6699)$$

八进制也是类似的。八进制平常使用很少，这里不再讲解。


## 二进制算术

```shell
    1001011
 +  1100101
────────────
```

```shell
         1
    1001011
 +  1100101
────────────
          0
```


## 寄存器和内存

寄存器占据内存层次结构的最高层。它们位于 CPU 本身上，可以通过指令直接访问，因此是存储您正在使用的值的最快位置。另一方面，由于它们在物理上必须靠近CPU，因此不能占用太多空间；x86-64有16个64位通用寄存器，16个128位浮点/SIMD寄存器，以及一些特殊用途寄存器。


### 通用寄存器

通用寄存器的排列方式是将全部 64 位划分为低 32 位、低 16 位和低（有时是高）8 位。例如，对于 rax：


只有寄存器 rax、rbx、rcx 和 rdx 允许通过 ah、bh、ch 和 dh 访问高字节（低字，因此它实际上位于整个寄存器的中间）。使用它们的时间/地点有一些限制（在 64 位模式下）。


|64-bits| 低32bits| 低16bits| 低8bits| 描述| 
|--|--|--|--|--|
|rax|eax|ax|al|系统调用的操作码和返回值，累加器|
|rbx|ebx|bx|bl|基址寄存器|
|rcx|ecx|cx|cl|循环计数， 系统调用临时寄存器|
|rdx|edx|dx|dl|系统调用的第三个参数|


当我们讨论函数时，我们会看到每个寄存器都属于一个额外的分类：

当我们调用一个函数时，我们是函数调用者负责在需要时保存寄存器（“被调用者保留的寄存器”），还是我们调用的函数负责在需要时保存寄存器（“调用者”） -保留的寄存器”）？

```rsp```和```rbp```虽然是通用寄存器，但是通常用于管理栈。```rsp```指向栈顶，而``` rbp```（基指寄存器）传统上指向当前函数堆栈帧的开头。rsp 不应用于其他用途，但 rbp 并非严格禁止使用。请注意，```rsp``` 指向栈顶部的元素，而不是其上方的空白空间。

```rax``` 称为累加器，并且一些指令隐式地使用它作为目的地。同样，rbx 有时称为“基址”寄存器，rcx 称为“计数寄存器”，rdx 称为“双字累加器”


### mov指令

汇编语言最基本的指令就是```mov```， 它将数据从一个位置移动(内存、寄存器、理解数)到另一个位置(内存、寄存器)。它具有一下的形式：

```x86asm
mov destination, source
```
其中目的操作数可以是寄存器或内存，源操作数可以是寄存器、内存或立即值。

目的操作数和源操作数的大小必须相同，并且源操作数和目的操作数不能同为内存类型。

```x86asm
add rax, some_huge_constant
```


```x86asm
mov rbx, some_huge_constant
add rax, rbx
```


### 交换寄存器的值

```x86asm
xchg a, b
```

### 清除寄存器

```x86asm
mov reg, 0
```

```x86asm
xor reg, reg
```


## 特殊用途的寄存器

以下寄存器用于特定目的，由 CPU 强制执行。您要么无法将一般数据放入其中，要么无法从中取出数据。通常必须使用专门的指令（不是 mov）来访问它们。
- rip 指令指针指向下一条要执行的指令（即紧接在这条指令之后的指令）。低 32 位可作为 eip 访问，低位字可作为 ip 访问，但由于地址始终是 64 位，因此这并不是特别有用。分支指令直接修改rip。
- rflags寄存器：标志寄存器的每一位都有不同的含义，并且根据某些操作的结果设置或取消设置各种标志。当我们了解测试和条件操作时，我们将深入研究标志寄存器。通常你不需要担心访问标志寄存器，因为它是由相关操作自动设置和测试的。