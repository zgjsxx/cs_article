---
category: 
  - 分布式系统
tag:
  - 分布式系统
---

# 不要满足于最终一致性：使用 COPS 实现广域存储的可扩展因果一致性

## 摘要

支持复杂在线应用（如社交网络）的地理复制分布式数据存储必须提供一种 "始终在线" 的体验，即操作始终以低延迟完成。如今的系统通常会牺牲强一致性来实现这些目标，向其客户端暴露不一致性，并需要复杂的应用逻辑。在本文中，我们识别并定义了一种一致性模型 —— 具有收敛冲突处理的因果一致性，即 causal+，这是在这些约束下所能实现的最强一致性。

我们展示了 COPS 的设计与实现，COPS 是一个键值存储，它在广域范围内提供这种一致性模型。COPS 的一个关键贡献是其可扩展性，它可以在整个集群中存储的键之间强制执行因果依赖关系，而不像以前的系统那样只在单个服务器上执行。COPS 的核心方法是在暴露写入之前，跟踪并明确检查本地集群中键之间的因果依赖关系是否得到满足。此外，在 COPS-GT 中，我们引入了获取事务，以便在不锁定或阻塞的情况下获得多个键的一致视图。我们的评估表明，COPS 在不到一毫秒的时间内完成操作，在每个集群使用一个服务器时提供与以前系统类似的吞吐量，并且随着我们增加每个集群中的服务器数量而具有良好的扩展性。它还表明，对于常见工作负载，COPS-GT 在延迟、吞吐量和扩展性方面与 COPS 类似。

### 1. 引言

分布式数据存储是现代互联网服务的基础构建块。理想情况下，这些数据存储应该具备以下特性：**强一致性**（strong consistency）、**对读写操作始终可用**（always available for reads and writes）、以及在**网络分区**（network partitions）期间能够继续运行。然而，CAP 定理明确证明，不可能创建一个同时满足这三种特性的系统。

因此，现代 Web 服务普遍选择在牺牲强一致性的前提下，优先实现 **可用性**（availability）和 **分区容忍性**（partition tolerance）。考虑到这种选择还能使系统提供低延迟的客户端操作和高可扩展性，这一取舍并不令人意外。此外，许多早期的大规模互联网服务（例如专注于 Web 搜索的系统）通常对强一致性没有太高要求。然而，随着互动性更强的服务（例如社交网络应用）的兴起，这种情况正在发生变化。

我们将具有以下四个特性的系统称为 ALPS 系统:
- Availability(即可用性)
- low Latency(低延迟)
- Partition-tolerance(分区容忍性)
- high Scalability(高可扩展性)

由于 ALPS 系统必须牺牲强一致性（例如线性一致性），我们希望在这种约束下实现最强的可用一致性模型。更强的一致性是可取的，因为它使程序员更容易理解和使用系统。在本文中，我们考虑了具有收敛冲突处理的因果一致性，我们将其称为 causal+ 一致性。许多之前被认为实现了较弱因果一致性的系统实际上实现了更有用的 causal+ 一致性，但没有一个系统以可扩展的方式实现它。

Causal+ 一致性中的因果一致性组件确保数据存储遵守操作之间的因果依赖关系。例如，假设一个用户将图片上传到网站，图片被保存后，又向该用户的相册中添加了一条指向该图片的引用。这种引用"依赖于"图片的保存。在 causal+ 一致性下，这些依赖关系始终能够得到满足。程序员不需要处理类似于弱一致性系统（如最终一致性）中可能遇到的情况，即可能获取到图片的引用但无法获取图片本身。

收敛冲突处理组件确保副本不会永久分歧，并且对同一键的冲突更新在所有站点以相同方式处理。当结合因果一致性时，该属性还确保客户端只会看到不断更新的键版本。相比之下，最终一致性系统可能会暴露乱序版本。通过将因果一致性与收敛冲突处理相结合，causal+ 一致性确保了客户端能够看到一个因果正确、无冲突且始终前进的数据存储。

我们的 COPS 系统（Order-Preserving Servers 的集群）提供 因果+一致性，旨在支持复杂的在线应用。这些应用托管在少量的大规模数据中心中，每个数据中心由前端服务器（COPS 的客户端）和后端键值数据存储组成。COPS 在本地数据中心以线性化的方式执行所有的 put 和 get 操作，然后以 因果+一致性 的顺序在后台跨数据中心复制数据。

我们详细介绍了 COPS 系统的两个版本。普通版本 COPS 提供了各数据项之间的可扩展 因果+一致性，即使它们的因果依赖分布在本地数据中心的许多不同机器上。这种一致性特性代价很低：COPS 的性能和开销与之前的系统（例如基于日志交换的系统【10, 41】）相似，同时提供了更大的可扩展性。

我们还介绍了系统的扩展版本 COPS-GT，它提供了能够使客户端获取多个键的 一致视图 的 get 事务。即使在完全线性化的系统中，也需要 get 事务来获得多个键的一致视图。我们的 get 事务无需锁定、是非阻塞的，并且最多需要两轮并行的跨数据中心内部请求。据我们所知，COPS-GT 是第一个在 ALPS 系统中实现非阻塞可扩展 get 事务的系统。这些事务确实有一定的成本：与普通版本的 COPS 相比，COPS-GT 在某些负载（例如写密集型）中效率较低，并且对长时间的网络分区和数据中心故障的鲁棒性较差。

ALPS 系统的可扩展性要求是 COPS 和之前因果+一致性系统之间最大的区别。之前的系统要求所有数据必须存储在单一机器上，或者所有可能被一起访问的数据必须存储在同一台机器上。相比之下，COPS 中存储的数据可以分布在任意大小的数据中心中，且依赖关系（或 get 事务）可以跨多个服务器。据我们所知，COPS 是第一个实现了可扩展 因果+一致性（进而实现因果一致性）的系统。

本文的主要贡献包括：
- 我们明确指出了分布式数据存储的四个重要特性，并用它们来定义 ALPS 系统。
- 我们命名并正式定义了 因果+一致性。
- 我们展示了设计与实现 COPS 的方法，该系统高效实现了 因果+一致性 模型。
- 我们在 COPS-GT 中提出了一种非阻塞、无锁的 get 事务算法，该算法可以在最多两轮本地操作中为客户端提供多个键的一致视图。
- 我们通过评估表明，COPS 在所有测试负载下都具有低延迟、高吞吐量和良好的可扩展性；而 COPS-GT 在常见负载下具有类似的性能特性。

## 2. ALPS 系统与权衡

我们关注能够支持当今最大互联网服务的基础设施。与传统的集中于小规模局域网操作的分布式存储系统相比，这些服务通常具有跨广域部署的特点，分布范围从几个到几十个数据中心，如图 1 所示。每个数据中心包含一组应用层客户端，以及一个后端数据存储，这些客户端从中读取和写入数据。对于许多应用（包括本文讨论的场景），在一个数据中心写入的数据会被复制到其他数据中心。

通常，这些客户端实际上是代表远程浏览器运行代码的网页服务器（web server）。尽管本文从应用客户端（即网页服务器）的视角讨论一致性，但如果浏览器通过单个数据中心访问服务，正如我们预期的那样，它也将享有类似的一致性保证。

这样的分布式存储系统有多个（有时相互竞争的）目标，包括：可用性、低延迟和分区容错性，以提供"始终在线"的用户体验；可扩展性，以适应不断增长的负载和存储需求；以及足够强的一致性模型，以简化编程并为用户提供符合预期的系统行为。具体来说，这些理想特性包括：
- 1.可用性（Availability）:所有向数据存储发出的操作都能成功完成。没有操作会无限期阻塞或返回表示数据不可用的错误。
- 2.低延迟（Low Latency）:客户端操作能"快速"完成。商业服务级别目标（Service Level Objectives）建议平均性能为几毫秒，而最差情况（即第 99.9 百分位）的性能在几十到几百毫秒之间。
- 3.分区容错性（Partition Tolerance）。即使发生网络分区（例如将亚洲和美国的数据中心分隔开），数据存储仍能继续运行。
- 4.高可扩展性（High Scalability）。数据存储能够线性扩展。向系统增加 𝑁 个资源，其总吞吐量和存储容量相应地增加 𝑂(𝑁)。
- 5.更强的一致性（Stronger Consistency）。理想的存储系统应提供线性化一致性（linearizability），有时也被称为强一致性。这意味着操作在整个系统中似乎在其调用与完成之间的某一瞬间生效。在提供线性化一致性的存储系统中，当一个客户端在一个数据中心完成对某对象的写操作后，所有其他数据中心对同一对象的读操作将反映出该对象的最新状态。线性化一致性简化了编程——分布式系统提供了单一、一致的镜像，用户也能够体验到符合预期的存储行为。较弱的最终一致性模型（eventual consistency）在许多大型分布式系统中较为常见，但它们较难理解：不仅随后的读取可能不会反映最新值，还可能在读取多个对象时返回旧值和新值混杂的不一致结果。
  
CAP 定理证明了一个共享数据系统如果具备可用性和分区容错性，则无法实现线性化一致性（linearizability）。此外，低延迟（定义为低于跨广域副本之间的最大延迟）也已被证明与线性化一致性和顺序一致性（sequential consistency）不相容。

为了在 ALPS 系统的需求与编程易用性之间取得平衡，我们在下一节中定义了一种中间一致性模型。

## 3. 因果+一致性

为了定义具有收敛冲突处理的因果一致性（causal+ consistency），我们首先描述其运行的抽象模型。我们将讨论限制在一个键值数据存储（key-value data store）上，具有以下两个基本操作：put(key, val) 和 get(key) = val。这些操作等价于共享内存系统中的写操作和读操作。

值从逻辑副本中存储和检索，每个逻辑副本托管整个键空间。在我们的 COPS 系统中，一个逻辑副本对应于一个本地节点集群。

在该模型中，一个重要的概念是操作之间的潜在因果性（potential causality）。潜在因果性通过以下三条规则定义，用符号 ≺≺ 表示：

**1.执行线程（Execution Thread）**

如果 a 和 b 是同一执行线程中的两个操作，且操作 𝑎 先于操作 𝑏 发生，则 a -> b。

**2.来源关系（Gets From）**

如果a 是一个 put 操作，b 是一个 get 操作，并且 b 返回了由 a 写入的值，则 a -> b。

**3.传递性（Transitivity）**

对于操作a, b 和 c，如果 a -> b 且 b -> c，则 a -> c。

这些规则建立了在同一执行线程内的操作之间的潜在因果性，以及通过数据存储交互的操作之间的潜在因果性。与许多模型一样，我们的模型不允许线程直接通信，而是要求所有通信都通过数据存储进行。

示例

图 2 中的执行示例展示了所有三条规则：

- 执行线程规则：get(y) = 2 ->  put(x, 4)。
- 来源关系规则：put(y, 2) ->  get(y) = 2。
- 传递性规则：put(y, 2) ->  put(x, 4)。

即使某些操作在时间上跟随 put(x, 3) 之后，但没有其他操作依赖它，因为没有读取它写入的值，也没有在同一执行线程中紧接它发生。

![图2展示副本中操作之间因果关系的图。图中从 a 到 𝑏 的一条边表示 a≺b，即 b 依赖于 a](https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/lesson17/paper/fig2-graph-causal-relationship.png)

### 3.1 定义

我们将因果+一致性定义为以下两个属性的结合：**因果一致性**和**收敛的冲突处理**。在此给出直观定义，正式定义见附录 A。

因果一致性要求，副本中 get 操作返回的值必须与因果关系（->）定义的顺序一致。

换句话说，写入一个值的操作看起来必须发生在所有因果上先于它的操作之后。例如，在图 2 中，必须显得 put(y, 2) 发生在 put(x, 4) 之前，而 put(x, 4) 又发生在 put(z, 5) 之前。

如果客户端 2 先看到了 get(x) = 4，然后又看到 get(x) = 1，则因果一致性会被破坏。

因果一致性不对并发操作排序。如果 $a \not \rightarrow b$ 且$b \not \rightarrow a$, 则 a 和 b 是并发的。这通常可以提高实现效率：两个不相关的 put 操作可以以任意顺序复制，而无需对它们进行串行化处理。然而，如果 a 和 b 都是对同一键的 put 操作，则它们之间存在冲突。


冲突带来两个主要问题：副本可能永久分歧。由于因果一致性未对冲突排序，不同副本可能会永远保留不同的结果。例如，如果a 是 put(x, 1)，b 是 put(x, 2)，因果一致性允许一个副本对 𝑥 永远返回 1，而另一个副本对 𝑥 永远返回 2。

冲突可能表示某些需要特殊处理的异常情况。例如，在购物车应用中，如果两个人同时登录同一账户并添加商品到购物车，期望的结果是购物车
最终包含两件商品。

收敛的冲突处理要求，所有副本以相同的方式处理冲突的 put 操作，使用一个处理函数 h。这个处理函数 h 必须是结合律和交换律的，以确保副本可以按照其接收到的顺序处理冲突的写入，并且处理结果能够收敛。例如，一个副本执行 另一个副本执行 两者结果必须一致。

一种常见的收敛冲突处理方式是最后写入者胜出规则（Last-Writer-Wins, LWW），也称为 Thomas 写规则。该规则将冲突中的某一次写入标记为"更晚发生"，并覆盖更早的写入。另一种常见方法是标记这些冲突，并通过其他方式解决，例如通过用户干预，或通过编程过程。

所有潜在形式的收敛冲突处理都避免了第一个问题（冲突更新可能不断分歧），通过保证副本在交换操作后达到相同的结果。然而，解决第二个问题（应用可能需要特殊处理冲突）则依赖更显式的冲突解决流程。这些显式流程为应用提供了更大的灵活性，但也需要额外的编程复杂性和/或性能开销。

尽管 COPS 系统可以配置为显式检测冲突更新并应用某些应用定义的解决方法，COPS 默认使用最后写入者胜出规则来处理冲突。

### 3.2 因果+与其他一致性模型

分布式系统文献中定义了几种流行的一致性模型，按照一致性的强度递减排序，包括：

- 线性化一致性（或强一致性），保持全局的实时排序。
- 顺序一致性：确保至少存在全局排序。
- 因果一致性：确保依赖操作之间的部分排序。
- FIFO（PRAM）一致性：只保留执行线程之间的部分排序，而不是线程之间的排序。
- 每个键的顺序一致性：确保每个单独的键的所有操作都具有全局排序。
- 最终一致性：一种通用术语，今天通常表示最终会收敛到某种类型的协议或一致性状态。

我们提出的因果+一致性介于顺序一致性和因果一致性之间，如图3所示。它比顺序一致性弱，但顺序一致性在ALPS系统中是无法实现的。然而，它比因果一致性和每个键的顺序一致性要强，并且对于ALPS系统是可实现的。Mahajan等人也同时定义了一个类似的因果一致性加强版本；有关详细信息，请参见第7节。

为了说明因果+模型的实用性，考虑两个例子。在第一个例子中，假设爱丽丝尝试与鲍勃分享一张照片。爱丽丝上传了照片，然后将照片添加到她的相册中。接着，鲍勃查看爱丽丝的相册，期望看到她的照片。在因果一致性以及因果+一致性下，如果相册中有照片的引用，那么鲍勃必须能够查看到这张照片。而在每个键的顺序一致性和最终一致性下，相册中可能会有指向照片的引用，但该照片实际上可能还没有被写入。



## ps

线性一致性 顺序一致性

https://www.codedump.info/post/20220710-weekly-22/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7