---
category: 
  - 分布式系统
tag:
  - 分布式系统
---

- [Zookeeper](#zookeeper)
  - [1.介绍](#1介绍)
  - [2](#2)
    - [2.3 ZooKeeper 保证](#23-zookeeper-保证)
    - [2.4 源语示例](#24-源语示例)

# Zookeeper

在本文中，我们介绍了 ZooKeeper，一种用于协调分布式应用程序进程的服务。由于 ZooKeeper 是关键基础设施的一部分，因此 ZooKeeper 的目标是为在客户端构建更复杂的协调原语提供一个简单且高性能的内核。它在一个复制的集中式服务中融合了组消息传递、共享寄存器和分布式锁服务的元素。ZooKeeper 所暴露的接口具有共享寄存器的无等待特性，以及与分布式文件系统的缓存失效类似的事件驱动机制，以提供一种简单而强大的协调服务。

ZooKeeper 的接口实现了一种高性能的服务。除了无等待特性之外，ZooKeeper 还为每个客户端提供了请求的先入先出执行保证，以及对所有改变 ZooKeeper 状态的请求的线性一致性。这些设计决策使得能够实现一个高性能的处理管道，其中读取请求由本地服务器满足。我们展示了对于目标工作负载（读取与写入比例为 2:1 到 100:1），ZooKeeper 能够每秒处理数万到数十万个事务。这种性能使得 ZooKeeper 能够被客户端应用程序广泛使用。

## 1.介绍

大规模分布式应用程序需要不同形式的协调。通常有下面三种形式的协调：

- 配置是最基本的协调形式之一。在其最简单的形式中，配置只是系统进程的一系列操作参数列表，而更复杂的系统则具有动态配置参数。
- 组成员关系和领导者选举在分布式系统中也很常见：通常进程需要知道其他哪些进程是活跃的以及这些进程负责什么。
- 锁构成了一种强大的协调原语，它实现了对关键资源的互斥访问。

一种协调的方法是为不同的协调需求分别开发服务。例如，亚马逊SQS 专门聚焦于队列。其他服务是专门为领导者选举和配置而开发的。实现更强大原语的服务可以用来实现较弱的原语。例如，Chubby 是一种具有强大同步保证的锁服务。然后，锁可以用来实现领导者选举、组成员关系等。

在设计我们的协调服务时，我们不再在服务器端实现特定的原语，而是选择公开一个应用程序开发人员能够用来实现他们自己原语的 API。这样的选择导致了一个协调内核的实现，它能够实现新的原语而不需要对服务核心进行更改。这种方法实现了适应应用程序需求的多种协调形式，而不是将开发人员限制在一组固定的原语中。

在设计 ZooKeeper 的 API 时，我们摒弃了诸如锁之类的阻塞原语。对于协调服务而言，阻塞原语可能会导致诸多问题，比如速度慢或有故障的客户端会对速度较快的客户端的性能产生负面影响。如果服务的实现本身依赖于其他客户端的响应和故障检测来处理请求，那么服务的实现就会变得更加复杂。我们的系统 ZooKeeper 因此实现了一个 API，该 API 操作简单的无等待数据对象，这些对象像在文件系统中一样分层组织。实际上，ZooKeeper 的 API 类似于任何其他文件系统的 API，仅从 API 签名来看，ZooKeeper 似乎是没有锁方法、打开和关闭方法的 Chubby。然而，实现无等待数据对象使 ZooKeeper 与基于诸如锁等阻塞原语的系统有很大的不同。

尽管无等待特性对于性能和容错性很重要，但对于协调来说它是不够的。我们还必须为操作提供顺序保证。特别是，我们发现保证所有操作的先入先出（FIFO）客户端顺序以及线性化写入能够实现高效的服务实现，并且足以实现我们的应用程序所关注的协调原语。实际上，我们可以使用我们的 API 为任意数量的进程实现共识，并且根据赫利希（Herlihy）的层次结构，ZooKeeper 实现了一个通用对象。

ZooKeeper 服务由一组服务器组成，这些服务器使用复制来实现高可用性和高性能。它的高性能使得由大量进程组成的应用程序能够使用这样一个协调内核来管理协调的各个方面。

我们能够使用一个简单的流水线架构来实现 ZooKeeper，该架构允许我们有数百或数千个未完成的请求，同时仍然实现低延迟。这样的流水线自然能够以FIFO的顺序执行来自单个客户端的操作。保证客户端的先入先出顺序使客户端能够异步提交操作。通过异步操作，客户端能够同时有多个未完成的操作。例如，当一个新客户端成为领导者并且必须操作元数据并相应地进行更新时，这个特性是很理想的。如果没有多个未完成操作的可能性，初始化时间可能是秒级而不是亚秒级。

为了确保更新操作满足线性一致性，我们实现了一个基于领导者的原子广播协议，称为 Zab。然而，ZooKeeper 应用程序的典型工作负载以读取操作为主，因此提高读取吞吐量就变得很有必要。在 ZooKeeper 中，服务器在本地处理读取操作，我们不使用 Zab 对它们进行完全排序。

在客户端缓存数据是提高读取性能的一项重要技术。例如，对于一个进程来说，缓存当前领导者的标识符是很有用的，而不是每次需要知道领导者时都去探测 ZooKeeper。ZooKeeper 使用一种观察（watch）机制，使客户端能够缓存数据而无需直接管理客户端缓存。通过这种机制，客户端可以观察给定数据对象的更新，并在更新时接收通知。Chubby 直接管理客户端缓存。它阻止更新以使缓存正在被更改的数据的所有客户端的缓存失效。在这种设计下，如果这些客户端中的任何一个速度慢或有故障，更新就会被延迟。Chubby 使用租约来防止有故障的客户端无限期地阻塞系统。然而，租约只是限制了速度慢或有故障的客户端的影响，而 ZooKeeper 的观察机制则完全避免了这个问题。

## 2

### 2.3 ZooKeeper 保证

ZooKeeper 有两个基本的顺序保证：
- **线性化写入**：所有更新 ZooKeeper 状态的请求都是可序列化的，并且遵循先后顺序；
- **先进先出的客户端顺序**：来自给定客户端的所有请求都按照客户端发送的顺序执行。

请注意，我们对线性一致性的定义与赫利希（Herlihy）最初提出的定义不同，我们称之为 A - 线性一致性（异步线性一致性）。在赫利希对线性一致性的原始定义中，一个客户端一次只能有一个未完成的操作（一个客户端是一个线程）。在我们的定义中，我们允许一个客户端有多个未完成的操作，因此我们可以选择不保证同一客户端的未完成操作的特定顺序，或者保证先进先出顺序。我们为我们的属性选择了后者。重要的是要注意，所有适用于线性一致对象的结果也适用于 A - 线性一致对象，因为满足 A - 线性一致性的系统也满足线性一致性。由于只有更新请求是 A - 线性一致的，ZooKeeper 在每个副本上本地处理读请求。这使得服务能够随着服务器添加到系统中而线性扩展。

为了了解这两个保证是如何相互作用的，考虑以下场景。一个由多个进程组成的系统选举出一个领导者来指挥工作进程。当一个新的领导者接管系统时，它必须更改大量的配置参数，并在完成后通知其他进程。那么我们有两个重要的要求：
- 当新的领导者开始进行更改时，我们不希望其他进程开始使用正在被更改的配置；
- 如果新的领导者在配置完全更新之前死亡，我们不希望进程使用这个部分配置。

注意，分布式锁（例如由 Chubby 提供的锁）有助于满足第一个要求，但对于第二个要求来说是不够的。在 ZooKeeper 中，新的领导者可以指定一个路径作为就绪节点（ready znode）；只有当那个节点存在时，其他进程才会使用配置。

新的领导者通过删除 "就绪" 节点、更新各种配置节点并创建 "就绪" 节点来进行配置更改。所有这些更改都可以进行流水线处理并异步发出，以快速更新配置状态。尽管更改操作的延迟约为 2 毫秒，但如果请求一个接一个地发出，那么一个必须更新 5000 个不同节点的新领导者将需要 10 秒钟。

### 2.4 源语示例

在本节中，我们展示如何使用 ZooKeeper API 来实现更强大的原语。ZooKeeper 服务对这些更强大的原语一无所知，因为它们完全是在客户端使用 ZooKeeper 客户端 API 实现的。一些常见的原语，如组成员关系和配置管理，也是无等待的。对于其他原语，如会合（rendezvous），客户端需要等待一个事件。即使 ZooKeeper 是无等待的，我们也可以用 ZooKeeper 实现高效的阻塞原语。ZooKeeper 的顺序保证允许对系统状态进行高效推理，而观察机制允许进行高效等待。

**配置管理**：ZooKeeper 可用于在分布式应用程序中实现动态配置。在其最简单的形式中，配置存储在一个节点（znode）zc 中。进程启动时带有 zc 的完整路径名。启动的进程通过读取设置了观察标志为真的 zc 来获取它们的配置。如果 zc 中的配置被更新，进程将被通知并读取新的配置，再次将观察标志设置为真。

请注意，在这个方案中，就像在大多数使用观察机制的其他方案中一样，观察机制被用来确保进程拥有最新的信息。例如，如果一个正在观察 zc 的进程收到了 zc 发生变化的通知，而在它能够对 zc 发出读取请求之前，zc 又发生了三次变化，那么该进程不会再收到三个通知事件。这不会影响进程的行为，因为这三个事件只是会通知进程一些它已经知道的事情：它拥有的关于 zc 的信息已经过时了。

**简单锁**：尽管 ZooKeeper 不是一个锁服务，但它可以被用来实现锁。使用 ZooKeeper 的应用程序通常会使用根据其需求定制的同步原语，比如上面展示的那些。在这里，我们展示如何用 ZooKeeper 实现锁，以表明它可以实现各种各样的通用同步原语。
最简单的锁实现使用 “锁文件”。锁由一个节点（znode）表示。为了获取锁，客户端尝试使用临时（EPHEMERAL）标志创建指定的节点。如果创建成功，客户端就持有了锁。否则，客户端可以读取这个节点并设置观察标志，以便在当前持有锁的客户端失效时得到通知。当客户端死亡或显式删除这个节点时，它就释放了锁。其他正在等待锁的客户端一旦观察到这个节点被删除，就会再次尝试获取锁。
虽然这个简单的锁协议是有效的，但它确实存在一些问题。首先，它受到羊群效应的影响。如果有很多客户端在等待获取锁，当锁被释放时，它们都会争抢这个锁，尽管只有一个客户端能够获取到锁。其次，它只实现了排他锁。下面的两个原语展示了如何克服这两个问题。


**无惊群效应的简单锁**：

使用 ZooKeeper 实现分布式锁的基本思想是利用 ZooKeeper 的有序临时节点（ephemeral sequential znode）来创建唯一的锁节点，并通过观察节点的顺序来决定哪个客户端获得锁。当节点被删除时，ZooKeeper 会自动通知下一个客户端，从而实现分布式锁的公平释放与竞争。

ZooKeeper 实现分布式锁的步骤:
- 创建锁节点：每个客户端在特定路径下创建一个有序临时节点（ephemeral sequential znode）。例如，所有客户端在路径 /lock 下创建类似于 /lock/lock-00000001 的节点。
- 获取锁：客户端获取当前路径下的所有节点，并对节点排序。若自己的节点在排序后的节点列表中最小，则获得锁。若不是最小节点，则监视比自己小的上一个节点（确保有序性）。
- 释放锁：当持有锁的客户端完成任务时，删除自己的节点。这时，ZooKeeper 会通知下一个节点（即排名第二小的节点），使其获得锁。
- 故障处理：ZooKeeper 会自动删除已失联客户端的临时节点，因此其他客户端可以检测到锁已释放，并进行重新竞争。

总之，这个锁方案有以下优点：
- 删除一个节点只会唤醒一个客户端，因为每个节点恰好被另一个客户端观察，所以我们没有惊群效应效应
- 没有轮询或超时；
- 由于我们实现锁的方式，我们可以通过浏览 ZooKeeper 数据看到锁竞争的程度、打破锁以及调试锁问题。