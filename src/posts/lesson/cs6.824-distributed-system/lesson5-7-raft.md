---
category: 
  - 分布式系统
tag:
  - 分布式系统
---

- [raft算法](#raft算法)
  - [5.raft一致性算法](#5raft一致性算法)
    - [5.1 raft算法基础](#51-raft算法基础)
      - [5.1.1 raft状态机](#511-raft状态机)
      - [5.1.2 raft任期](#512-raft任期)
      - [5.1.3 raft节点通讯](#513-raft节点通讯)
    - [5.2 Leader选举](#52-leader选举)
      - [5.2.1 选举过程](#521-选举过程)
      - [5.2.2 选举成功的条件](#522-选举成功的条件)
    - [5.2.3 如何避免无限循环的投票分裂](#523-如何避免无限循环的投票分裂)
    - [5.3 日志复制](#53-日志复制)
  - [问题](#问题)
    - [raft算法，有没有可能有多个candidate同时获得了多数票？](#raft算法有没有可能有多个candidate同时获得了多数票)
  - [资源](#资源)

# raft算法

## 5.raft一致性算法

### 5.1 raft算法基础

#### 5.1.1 raft状态机

一个 Raft 集群包含若干个服务器；通常有五个，这使得系统可以容忍两个节点发生故障。

在任何特定时间，每个服务器都处于三种状态之一：**领导者**（leader）、**跟随者**（follower）或者**候选者**（candidate）。

- 在正常运行时，只有**一个领导者**，其他所有服务器**都是跟随者**。
- 跟随者是被动的，它们自身不发出请求，而只是响应来自领导者和候选者的请求。
- 领导者处理所有客户端请求， 如果客户端与一个跟随者联系，跟随者会将**其重定向到领导者**。
- 候选者是一个特殊状态，用于选举新的领导者。

下图展示了这些状态及其转换：

![raft服务器状态](https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/raft-server-state.png)

#### 5.1.2 raft任期

下一个要介绍的概念是**任期**。Raft 算法将时间划分为任意长度的任期，任期用**连续的整数编号**。每个任期都以一次选举开始，在选举中，一个或多个候选人尝试成为领导者。如果一个候选人在选举中获胜，那么它将在该任期的剩余时间里担任领导者。在某些情况下，选举会导致选票分散。在这种情况下，该任期将结束且没有领导者；一个新的任期（伴随着新的选举）很快就会开始。Raft 算法确保在一个特定任期内最多只有一个领导者。

![raft任期](https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/raft-term.png)

关于raft，有以下几点需要说明：
- 每个任期的开始都是从**选举**开始，选举时可能有多个都试图成为leader。
- 某个candidate赢得选举之后，就会成为该任期内的leader。
- 每个节点都记录了当前的**任期号**（currentTerm），这个编号时随着时间单调递增。
- 节点通信时，会带上自己的任期号
  - 如果自己的任期号小于其他节点的，要立即将自己的任期号更新为更大的任期号。
  - 如果一个candidate或leader发现自己的任期过期了，要立即切换到follower状态。
  - 如果一个节点收到了携带过期任期编号的请求，会拒绝这个请求。

#### 5.1.3 raft节点通讯

raft服务器RPC进行通讯，主要通讯交互是两种：

- RequestVote： 由candidates在选举期间发起
- AppendEntries： 由leader发起，用于复制日志条目以及提供一种心跳（heartbeat）形式。

### 5.2 Leader选举

Raft 使用**心跳机制**来触发领导者选举。
- 当服务器启动时，它们以跟随者（follower）状态开始。只要服务器从领导者或候选人那里接收到有效的远程过程调用（RPC），它就会保持在跟随者状态。
- 领导者会定期向所有跟随者发送心跳（空的AppendEntries消息）以维护其权威性。
- 如果一个跟随者在一段称为选举超时（election timeout）的时间内没有收到任何通信，那么它会假定没有有效的领导者，并开始进行选举以选出新的领导者。

#### 5.2.1 选举过程

对于一个follower，当其发生选举超时时，将开始选举，具体过程如下
- 增加它的当前任期
- 将状态机切换到candidate状态。
- 然后选举自己作为leader，同时并发地向集群其他节点发送RequestVote RPC

对于该follower，其选举结果可能由如下三种：
- 该follower赢得此次选举，成为leader
- 另一个节点赢得此次选举，成为leader
- 选举超时，没有产生有效leader

#### 5.2.2 选举成功的条件

如果候选人在同一任期内获得了整个集群中**大多数服务器**的选票，它就赢得了选举。在给定的任期内，每个服务器最多为一个候选人投票，遵循**先到先得**的原则。多数原则确保了在特定任期内最多只有一个候选人能够赢得选举。一旦候选人赢得选举，它就成为领导者。然后它向所有其他服务器发送心跳消息以确立其权威并防止新的选举。

在等待投票期间，一个 candidate 可能会从其他服务器收到一个 AppendEntries RPC 声称自己是 leader。这个 leader 的任期 term 包含在 RPC 消息中，根据term值，分两种情况处理：

 - 该term大于等于这个 candidate 的 currentTerm：那该 candidate 就承认 这个 leader 是合法的，然后回归到 follower 状态。
 - 该term小于这个 candidate 的 currentTerm：拒绝这个 RPC ，仍然留在 candidate 状态。

第 3 种可能的结果是：该 candidate 既没有赢得也没有输掉这次选举。 如果多个 followers 在同一时间成为 candidates，投票就会很分散，最终没有谁能赢得大多数选票。 当发生这种情况时，每个 candidate 都会超时，然后各自增大 term 并给其他节点发送 RequestVote 请求，开始一轮新选举， 但如果没有额外的预防措施，**这种投票分裂的情况看可能会无限持续下去**。

### 5.2.3 如何避免无限循环的投票分裂

Raft 使用**随机化的选举超时时间**来确保选票分散（split votes）的情况很少发生并且能够被快速解决。

为了从一开始就防止选票分散的情况，选举超时时间是从一个固定区间（例如，150 - 300 毫秒）中随机选择的。这样可以分散服务器的超时时间，使得在大多数情况下只有一台服务器会超时；这台服务器赢得选举并在其他服务器超时之前发送心跳信息。同样的机制也被用于处理选票分散的情况。每个候选人在选举开始时重新启动其随机化的选举超时时间，并在该超时时间结束后才开始下一次选举；这降低了在新选举中再次出现选票分散的可能性。9.3 节表明这种方法可以快速选出领导者。

作者这里提到了曾经设计过使用排名系统来解决选票分散问题，即每个候选人被分配一个唯一的排名，该排名用于在相互竞争的候选人之间进行选择。如果一个候选人发现另一个具有更高排名的候选人，它将返回跟随者状态，以便更高排名的候选人可以更容易地赢得下一次选举。但是这种方法在可用性方面产生了一些微妙的问题。如果高排名的服务器出现故障，低排名的服务器可能需要超时并再次成为候选人，但如果它太快这样做，可能会重置选举领导者的进度）。我们对该算法进行了多次调整，但每次调整后都会出现新的极端情况。最终我们得出结论，随机重试方法更加直观和易于理解。

综上所述，作者选择了使用**随机化选举超时时间**解决选票分散问题。

### 5.3 日志复制

一旦选举出领导者，它就开始处理客户端请求。每个客户端请求都包含一个要由复制状态机执行的命令。领导者将该命令作为新条目追加到其日志中，然后并行地向其他每个服务器发出附加条目（AppendEntries）RPC 以复制该条目。当该条目已被安全复制（如下所述）时，领导者将该条目应用于其状态机，并将该执行结果返回给客户端。如果跟随者崩溃或运行缓慢，或者网络数据包丢失，领导者会无限期地重试附加条目 RPC（即使在它已经响应客户端之后），直到所有跟随者最终存储所有日志条目。

![raft日志项](https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/raft-logs-entries.png)

## 问题

### raft算法，有没有可能有多个candidate同时获得了多数票？

在 Raft 共识算法中，多个 candidate 节点同时获得多数票的情况是不可能的。

主要有两个原因：

- 单一投票规则

在每一轮选举（即每个任期 term）中，每个节点只能投票给一个 candidate。因此，一个节点不可能同时把票投给两个不同的 candidate。这意味着，多个 candidate 要同时获得多数票，在逻辑上是互斥的。

- 选举时间随机化

每个节点的 Election Timeout 是随机的，因此不同节点转变为 candidate 并发起选举的时间点通常不会相同。由于超时时间不同，首先发起选举的 candidate 很可能已经赢得了选举，其他节点在同一轮投票中无法再成为 leader。

## 资源

- [raft官方动画](https://raft.github.io/)
- http://arthurchiao.art/blog/raft-paper-zh/