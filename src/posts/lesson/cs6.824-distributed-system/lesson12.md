---
category: 
  - 分布式系统
tag:
  - 分布式系统
---

- [cs-6.824第12讲 分布式事务](#cs-6824第12讲-分布式事务)
  - [并发控制](#并发控制)
  - [原子提交](#原子提交)
  - [总结](#总结)

# cs-6.824第12讲 分布式事务

**分布式事务**之所以出现，是因为很多业务拥有大量的数据，这些数据最终会被分割或分片到不同的服务器上。

例如，你正在运行一家银行，那么可能一半客户的银行余额存储在一台服务器上，而另一半客户的银行余额则存储在另一台服务器上。这样做就可以**分散负载**，分散负载包含包括**分散处理**和**分散存储**两个点。再例如，如果你正在网站上记录文章的投票数，或者存在数以百万计的文章，其中一半的票数统计在一个服务器上，而另一半则分布在另一个服务器上。

但是有一些操作需要接触、修改或读取分布在不同服务器上的数据。以上面的银行的例子，如果执行一个客户到另一个客户的银行转账，那么他们的余额可能存储在不同的服务器上，因此为了实现平衡，我们必须对两个不同的服务器上的数据进行修改、读取和写入操作。

我们希望做到的是试图隐藏数据分散到多个服务器上，尽量不让应用程序开发者感知到。这就是分布式事务所产生的背景，所谓**事务**其实就是**并发控制**和**原子提交**。程序员拥有一系列不同的操作，可能针对数据库中的不同的记录进行，希望这些操作可以作为一个整体，不受故障或者其他活动影响而分割。 事务处理系统将要求程序员标记读写及更新操作序列的起始和结束，以便明确事务的起始和结束。

再次看银行的例子：

我们希望从用户x的账户向用户y的账户进行转账，现在他们双方的余额初始状态都是10。现在有两个事务：
- T1：一笔交易时从账户X向账户y转账一美元
- T2：对该银行进行审计，以确保银行资金总量不变。

```shell
x = 10  y = 10
T1：
BEGIN_X
    add(x, 1)
    add(y, -1)
END_X

T2:AUDIT
BEGIN_X
   t1 = get(x)
   t2 = get(y)
   print t1, t2
END_X
```

现在问题是，这两个事务的合法结果是什么?

再讨论这个之前，我们需要了解，什么样的结果是正确的。

**数据库事务**通常具有一个称为ACID的正确性概念，缩写为ACID。
- 原子性(A， atomic)，这意味着一个包含多个步骤的交易，可能涉及对多个不同记录的写入，若发生故障，无论何种故障，要么所有写入都完成，要么都不执行。(All or None on failure)
- 一致性(C， consistent)，数据库会执行应用程序所声明的不变量(不在本课讨论范围内)
- 隔离性(I，isolated)，两个同时运行的交易在完成之前是否能看到彼此变更的特性，期望值是不能看到。在技术层面，大多数人所指的隔离性，是指事务执行的**可串行化**（后续还会讲）。
- 持久性(D，durable)，在事务提交之后，事务的修改是持久的，它不会因为某些故障而被抹除。在实践中，这意味着数据必须被写入某种易失性戒指，如磁盘这样的持久存储设备。

这里面比较有意思的是隔离性（串行化）。如果存在某种顺序，使得事务串行执行的结果和实际并行执行的结果相同，则代表可以串行化。

这里回到上面的银行转账的例子， 由于只有两个事务T1和T2，所以只有两种顺序，先执行T1，再执行T2。或者先执行T2，再执行T1。因此我们分别看两种顺序所产生的结果,如下所示：

```shell
T1->T2: 
x=11 y=9 "11,9"

T2->T1:
x=11 y=9 "10,10"
```

只要事务不使用相同的数据，就允许真正的并行。在上面的例子中，我们使用了相同的数据x和y，因此不能并行。如果你有一个分片的系统，那么并行度可能会更高，因为数据分布在不同的机器上。一个事务完全在第一台机器的第一个分片上执行，而另一个事务则同时在第二个机器上并行。

事务可能由于某种原因，在执行过程中基本失败或决定失败，我们必须应对那些在执行中突然决定无法继续进行的事务的必要性。

## 并发控制

**并发控制**是用来提供**隔离性**和**串行化**的主要方法。

并发控制主要有以下两种：

- 悲观并发控制
- 乐观并发控制

悲观并发控制，通常依赖于锁机制。其含义是事务在使用任何数据之前，它需要获取该数据的锁。若其他事务已占该数据，锁将被保持，我们需等待以获取锁的释放，等待占有锁的事务完成。

乐观并发控制，核心思想是，你无需顾虑其他事务是否可能与你同时进行数据的读写操作，你只需直接执行你计划中的读写操作，只有在最后才去检查是否可能有其他事务可能产生干扰。如果此时，其他人在以冲突的方式修改同一数据，那么您就必须中止该事务并重试。(第14讲会涉及这个话题)。

如果冲突非常频繁，可能使用悲观并发控制更好。因为如果冲突非常频繁，乐观方案将会因为冲突而导致大量事务中止。

如果冲突不太常见，那么乐观控制可能更快，因为它完全避免了锁的开销。

今天主要讨论的是悲观并发控制。今天我们将探讨两阶段锁定(two-phase locking)，这是最常见的锁定类型。

两阶段锁定的思想是，
- 一个事务将会使用一堆记录，例如例子中的x和y，在使用任何数据片段之前(无论是读还是写)，都必须先获取锁。
- 一个事务必须在提交或终止之后才能释放其所获取的任何锁。在事务执行的过程中，不允许中途释放锁。

为了理解锁定在此处的作用，典型的锁定系统存在许多变种。通常，这些系统为数据库中的每条记录、每行和每张表分别关联一个独立的锁。回到上面的例子，当T1使用x时，必须在使用前获取x上的锁，并且可能等待。同理，对于y，也需要获取y上的锁，事务完成后才能释放这两个锁。

如果同时运行这两个事务，它们将竞争获取对x的锁定，无论哪个事务获取对x的锁定，它将得以继续执行并完成。于此同时，另一个未能获取到x锁的事务将在此等待，直到能够获取，它才可以对x进行操作。这里可以看到由于事务需要获取对x的锁定，实际上就实现了串行化。

接下来讨论一个问题，为什么你需要保持锁定直到事务全部完成才可以释放？

这里主要有两个原因：

- 第一个原因可能会违背线性化的要求
假设T2在箭头处，释放了x的lock，那么T1就可以继续执行，这种交错是违背线性化的。

```shell
T2:AUDIT
BEGIN_X
t1 = get(x)
--->release x lock
t2 = get(y)
print t1, t2
END_X
```

同样，如果T1在完成对x加1操作后，释放了对x的锁定，这允许T2的所有操作在此处插入。这也会违背线性化。

```shell
T1：
BEGIN_X
    add(x, 1)
---> release x lock
    add(y, -1)
END_X
```
- 第一个原因就是提前释放锁对于事务提前终止会产生问题。

如果在```add(x， 1)```之后释放了锁，然后随后由于y的余额不足，而导致y扣款失败，那么事务将会终止，将会对撤销对于x的更新，以保持原子性。 这个时候，由于T2可能会提前执行，T2可能会看到一个"幽灵"的11，这个值11后续因为T1的终止而消失。

这里还需讨论关于锁定锁产生的死锁问题。

假设我们有两个事务，其中一个读取x，然后读取y，另一个事务读取y，再读取x，如果它们同时运行，就会死锁。

```shell
T1：        T2:
Get(x)       Get(y)
Get(y)       Get(x)
```

事务通常会采取追踪循环或设置超时，以便检测到它们已陷入某种状态。当发现异常时，将终止其中一个事务。

到目前为止，我们所提到的概念都是标准数据库的行为，在单机数据库中如此，在分布式系统中也是如此。接下来将聚焦于分布式环境中支持事务处理。

我们有两台服务器，一台服务器存储我们的银行记录x。我们还有服务器2，可能它存储了记录y。因此它们都具有初始值10。还是以转账为例，将x加1，y进行减1。

```shell
    S1          S2  
|--------|  |--------|
| x | 10 |  | y | 10 |
|   |    |  |   |    |
|--------|  |--------|
```

如果我们不够谨慎，可能会遇到一种情况，服务器1为x增加余额，但随后发生了故障，导致我们未能完成对y的更新。

另一种情况下，服务器1为x增加余额，s2并未发生故障，但是可能y的值提示余额不足，无法扣款，但是x余额已经进行增加。

数据库事务的原子性要求交易要么完全完整，要么都不执行。上面两个场景显然违背了。在下一节中将讨论原子提交的问题，

## 原子提交

两阶段提交是一个原子提交协议，这个原理被很多分布式数据库采用，也被各种其他非传统数据库的分布式系统所应用。

我们假设有一个驱动事务的计算机，称为事务协调器。它可以向拥有不同数据片段的计算机发送消息。

```shell
            S1            
        |--------|  
        | x | 10 |  
        |   |    |  
        |--------|  
TC
        S2
        |--------|
        | y | 10 |
        |   |    |
        |--------|

```

事务协调器实际上会维护一个关于事务ID的表。

![两阶段提交](https://github.com/zgjsxx/static-img-repo/raw/main/blog/lesson/6.824/lesson12/two-phase-commit.png)

为了遵守两阶段的锁定规则，每个参与者在执行事务的一部分时，都会锁定其读取的任何数据。可以想象在每个**参与者**的内部，都存在一张与该参与者存储的数据先关联的表。参与者们会在这些表格中锁定信息。

如果所有人都遵循此协议且无任何故障发生，那么两位参与者只在双方均承诺的情况下才会提交。若其中任何一方无法提交，则双方均会终止。因此我们得到了期望的结果，要么它们都执行，要么都不执行。

接下来我们考虑各种异常的场景，看看两阶段提交如何解决这些场景。

**B可能在发送prepare确认消息之前就crash了**

那么B就不会回复prepare ok的消息，因此事务协调器不可能提交，因为它需要等待所有参与者的肯定答复。

**B可能在发送prepare确认消息之后crash会怎么样？**

这种场景将会麻烦一些。这种场景下，事务协调器将发送提交事务的请求，因为A和B在prepare阶段都发送了同意。B在经历崩溃和重启后仍不会丢失事务状态，原因在于B在回复准备请求之前，必须创建事务状态，即一种中间事务状态，记录所有已做的更改，这些更改在发生中止时可能需要撤销，同时还要记录该事务持有的所有锁，必须将其持久化到磁盘上，因此在B回复prepare yes的消息之前，必须将其日志中所有需要提交该事务的信息写入磁盘，即所有put操作生成的新值，以及一份完整的锁列表，会写入磁盘。接下来，当B发送了Yes之后crash，当其重新启动的时候，会查看日志， 然后提交事务。

因为在回复prepare yes之前，还需要对信息做持久化，因此两阶段提交的速度也会慢一些。

**B在接受到commit的消息之后崩溃，或者是处理完commit消息之后崩溃会怎么样？**

但在那种情况下，事务在接受到commit消息之前，已经将其所需的修改永久保存在数据库中，推测也已写入磁盘，在那种情况下，如果系统重新启动，可能需要采取任何措施，因为该事务已经完成。

因此当B接收到提交消息之后，它很可能会将日志中修改内容复制到永久存储中，释放锁，从日志中清除事务的信息，然后进行回复。


**如果收到两次commit消息会怎么样？**

可能的正确做法是，让B记住关于该事务的信息，这会占用内存，因此如果B只是忘记了它在磁盘上做持久化的已提价事务，当它会重复提交消息一无所知，只需要再次确认该事务，就可以回复重复的提交信息。

只要参与者之一可能已经提交，或者事务协调器已经向客户回复，我们都不能让事务消失。例如事务A已经提交，事务协调器可能已经向A发送了提交消息，却尚未向B发送提交消息，如此时发生崩溃，事务协调器必须在重启时准备重新发送提交消息，确保双方均知晓事务已经提交。


**如果事务协调器在发送了一个或多个commit消息之后崩溃**

事务协调器不能遗忘该事务。事务协调器在接受完prepare的回复消息之后，必须要将该事务的有关系信息写入持久化存储中。即使在崩溃重启之后，它仍然会存在。 事务协调器在接收到完整的是或否响应集合之后，会将结果即事务ID记录在磁盘日志中，仅在此之后才开始发送commit消息。如果在那个时间之后崩溃了，其恢复之后会在日志中发现，有事务还处于中间阶段，它会重新向参与者发送提交消息。


**事务协调器发送了准备消息，但是尚未从所有参与者收到yes或no的消息**

第一种选择是再次发送prepare的消息。 但是如果某个参与者长时间宕机，我们不希望一直持久锁在那里等待。因此如果在一定时间之内，事务协调器从未从参与者收到肯定或者否定的响应，那么它可以单方面决定中止。

**假设参与者B已经收到prepare请求，并发送了同意响应，但是一直没有收到commit请求**

这个时候B仍然持有记录的锁，作为B，他非常希望释放锁，因为可能还有很多事务还在等待获取该锁，问题是B等待了10分钟或者更久之后，他是否可以单方面中止该事务。 

答案是否定的。B需要阻塞的等待事务协调器的commit消息，可以理解为无限期等待。其原因是，由于B返回了prepare ok的消息，事务协调器可能已经收到了该回复，它可能已经开始发送commit消息了，这意味着A可能已经收到了提交事务，进行了提交。因此B无权单方面决定超时中止。

这种阻塞其实是两阶段提交的一个关键特征，这是一个非常令人不愉快的特点。这意味着，如果出现问题，你可能会陷入一种情况，即你必须长时间持有锁，并阻碍其他事务的进行。后续的很多研究都是围绕这个阻塞时间开展的。

只有事务协调器可以决定中止事务或者提交事务，任何一个参与者都没有权力单方面决定是否提交事务或者终止事务。

**事务协调器何时可以忘记其日志中关于事务的记录？**

如果系统成功接受所有来自参与者的完整确认信息，那么它就可以清除所有相关信息，即该事务的所有记录。同样的，当参与者接受到commit消息之后处理完所有的事情后，发送完成事务的消息之后，也可以清除关于该事务的信息。

## 总结

两阶段提交被广泛用于许多数据分片的数据库中。存在许多更为专业的存储系统，它们不允许对多个记录进行事务管理，那么这种情况则无需两阶段提交。

两阶段提交的劣势：

两阶段提交由于多轮消息提交而显得缓慢，而且还有大量的写盘操作。

两阶段提交并不保证高可用，需要结合raft和paxos才可以实现高可用。后面提到的Spanner实际就运用了这种方法。