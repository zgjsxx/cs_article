---
category: 
- network
---


# modbus-tcp

Modbus协议通过主站（客户端）和从站（服务器）之间的请求-应答机制来交换信息。主站-从站原理是一个用于通讯协议的模式，其中一个设备（主站）控制一个或多个其它设备（从站）。在标准的 Modbus 网络中，有 1个主站和最多31 个从站。

## MODBUS报文解析

| MBAP Header | Function code | Data |
|    Header   |          PDU         |

MBAP header包含下面几个部分：
- Transaction ID
- Protocol ID
- Length
- UnitID
- FCode
- Data

|id|名称|长度|说明|
|--|--|--|--|
|1|Transaction ID 事务处理标识 | 2字节| 报文的序列号，一般每次通讯加1，用于区别不同的报文 | 
|2|Protocol ID 协议标识| 2字节 | 00 00 代表modbus-Tcp |
|3|Length |2字节| Unit长度 + PDU的长度|
|4|UnitID| 单元标识符 | 1| 设备地址 |


|00 01| 00 00|00 06| 01 |

上述序列代表：事务标识为1，协议是modbus-tcp协议，数据长度是：6，从站号是1。

需要注意的是MODBUS协议是一个**大端**的协议，前两个byte 00 01代表0x1 , 因此Transaction ID=1。而长度字段00 06代表0x6， 即UnitID和PDU的长度总和为6。

modbus的操作对象有四种：线圈、离散输入、输入寄存器、保持寄存器。



功能码：
|功能码|功能|
|--|--|
|0x01|读单个或者多个线圈|
|0x05|写多个线圈|
|0x02|读离散量输入|
|0x04|读输入寄存器|
|0x03|读保持寄存器|
|0x06|写单个保持寄存器|
|0x10|写多个保持寄存器|


## 常用功能码

### 功能码0x1：读线圈寄存器

每个线圈寄存器可以存储一个bit的信息， 功能码0x01就是用于读取slave中线圈寄存器的状态，可以是**单个线圈寄存器**，也可以是**多个连续的线圈寄存器**。

**发送报文**

发送报文由下面几个部分组成，总共12字节：

MBAP header(7字节) + 功能码(1字节) + 线圈寄存器起始地址的高位（1字节） + 线圈寄存器起始地址的低位（1字节） + 线圈寄存器数量的高位（1字节） + 线圈寄存器数量的低位（1字节）

下面是一个用Modbus-Poll和Modbus-Slave测试的实际的例子，其含义是读取线圈寄存器的起始地址是0x0， 读取数量为 0x0a（十进制10）个。

![0x1-request](https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x1-request.png)


|MBAP header|功能码|起始地址高字节|起始地址低字节|寄存器数量的高位|寄存器数量的低位|
|--|--|--|--|--|--|
|01 66 00 00 00 06 01 | 01 | 00 | 00 | 00 | 0a |

其中：

TransanctionID = 358, Length = 6。

功能码为0x1，代表读取线圈寄存器。

读取的线圈寄存器的起始地址为0。

读取的线圈寄存器的数量为0xa(十进制10)个。

**响应报文**

响应报文的长度不是固定的，长度和用户请求的数据长度有关，由下面几个部分组成：

MBAP header(7字节) + 功能码(1字节) + 线圈寄存器的值

下面是一个实际的响应报文的内容:

![0x1-request](https://raw.githubusercontent.com/zgjsxx/static-img-repo/main/blog/network/modbus-tcp/modbus-0x1-response.png)


|MBAP header|功能码|字节数|请求的数据1|请求的数据2|
|--|--|--|--|--|
|01 66 00 00 00 05 01 | 01 | 02 | 21 | 02 |

返回的第一个字节21，转化为二进制为00100001， 其中bit0代表01寄存器，bit7代表07寄存器。

|0x7|0x6|0x5|0x4|0x3|0x2|0x1|0x0|
|--|--|--|--|--|--|--|--|
|0|0|1|0|0|0|0|1|

返回的第二个字节02，转化为二进制为00000010， 其中bit0代表08寄存器，bit1代表09寄存器。

|0x9|0x8|
|--|--|
|1|0|


### 写单个线圈寄存器0x05：

将从站中的一个输出写成ON或OFF，0xFF00请求输出为ON,0x000请求输出为OFF

请求：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）
响应：MBAP 功能码 输出地址H 输出地址L 输出值H 输出值L（共12字节）
如：将地址为0x0003的线圈设为ON
00 01 00 00 00 06 01 | 05 00 03 FF 00
回：写入成功
00 01 00 00 00 06 01  |05 00 03 FF 00


### 0x0F：写多个线圈

将一个从站中的一个线圈序列的每个线圈都强制为ON或OFF，数据域中置1的位请求相应输出位ON，置0的位请求响应输出为OFF

请求：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L 字节长度 输出值H 输出值L
响应：MBAP 功能码 起始地址H 起始地址L 输出数量H 输出数量L


### 0x02：读离散量输入

从一个从站中读1~2000个连续的离散量输入状态

请求：MBAP 功能码 起始地址H 起始地址L 数量H 数量L（共12字节）
响应：MBAP 功能码 数据长度 数据（长度：9+ceil（数量/8））
如：从地址0x0000开始读0x0012个离散量输入
00 01 00 00 00 06 01 02 00 00 00 12
回：数据长度为0x03个字节，数据为0x01 04 00，表示第一个离散量输入和第11个离散量输入为ON，其余为OFF
00 01 00 00 00 06 01 02 03 01 04 00


### 0x04：读输入寄存器

从一个远程设备中读1~2000个连续输入寄存器

请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）
响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)
如：读起始地址为0x0002，数量为0x0005的寄存器数据
00 01 00 00 00 06 01 04 00 02 00 05
回：数据长度为0x0A，第一个寄存器的数据为0x0c，其余为0x00
00 01 00 00 00 0D 01 04 0A 00 0C 00 00 00 00 00 00 00 00


### 0x03：读保持寄存器

从远程设备中读保持寄存器连续块的内容

请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）
响应：MBAP 功能码 数据长度 寄存器数据(长度：9+寄存器数量×2)
如：起始地址是0x0000，寄存器数量是 0x0003
00 01 00 00 00 06 01 03 00 00 00 03
回：数据长度为0x06，第一个寄存器的数据为0x21，其余为0x00
00 01 00 00 00 09 01 03 06 00 21 00 00 00 00


### 0x06：写单个保持寄存器

在一个远程设备中写一个保持寄存器

请求：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）
响应：MBAP 功能码 寄存器地址H 寄存器地址L 寄存器值H 寄存器值L（共12字节）
如：向地址是0x0000的寄存器写入数据0x000A
00 01 00 00 00 06 01 06 00 00 00 0A
回：写入成功
00 01 00 00 00 06 01 06 00 00 00 0A


### 0x10：写多个保持寄存器

在一个远程设备中写连续寄存器块（1~123个寄存器）

请求：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L 字节长度 寄存器值（13+寄存器数量×2）
响应：MBAP 功能码 起始地址H 起始地址L 寄存器数量H 寄存器数量L（共12字节）
如：向起始地址为0x0000，数量为0x0001的寄存器写入数据，数据长度为0x02，数据为0x000F
00 01 00 00 00 09 01 10 00 00 00 01 02 00 0F
回：写入成功
00 01 00 00 00 06 01 10 00 00 00 01




实现代码

https://github.com/fz-lyu/modbuspp


调试工具

modbus poll： modbus客户端工具(主站)

modbus slave: modbus服务端工具(从站)


参考文章
https://blog.csdn.net/qq_36958104/article/details/124193794