---
category: 
- 面经
tag:
- 数据库面经
---

- [数据库](#数据库)
  - [什么是关系型数据库范式？](#什么是关系型数据库范式)
  - [你对binlog日志和redolog日志了解吗？解释以下这两个日志的作用以及两阶段提交](#你对binlog日志和redolog日志了解吗解释以下这两个日志的作用以及两阶段提交)
  - [列举MySQL的四个隔离级别，并解释每个级别的区别以及可能产生的问题](#列举mysql的四个隔离级别并解释每个级别的区别以及可能产生的问题)
  - [MySQL可重复读完全解决了幻读问题吗？](#mysql可重复读完全解决了幻读问题吗)


# 数据库

## 什么是关系型数据库范式？

数据库范式（Normalization）是数据库设计中的一套规则，用于组织数据库中的数据，以**减少数据冗余**，提高数据的完整性和一致性。范式提供了一种系统化的方法来设计数据库结构，使得数据冗余最小化，并避免某些常见的数据库操作问题，如插入异常、删除异常和更新异常。

**1.第一范式（1NF）**

要求：数据库表中的所有字段值必须是不可再分的原子值。换句话说，**每一列**中的数据应当是不可分割的单一值。

示例：

假设有一张表 Student：

|StudentID|	Name|	PhoneNumber|
|--|--|--|
|1	|Alice|	123-4567|
|2	|Bob	|234-5678, 345-6789|

在这里，PhoneNumber列包含多个电话号码（234-5678, 345-6789），这不符合第一范式。要将其转换为1NF，应将每个电话号码分成单独的记录。

转换后：

|StudentID|	Name|	PhoneNumber|
|--|--|--|
|1	|Alice|	123-4567|
|2	|Bob	|234-5678|
|2	|Bob	|345-6789|

**2.第二范式（2NF）**

要求：在满足第一范式的基础上，数据库表中的每个非主属性必须完全依赖于整个主键，而不能依赖主键的一部分。适用于复合主键的表。

示例：

假设有一张表 OrderDetail，主键是由 OrderID 和 ProductID 组成：

|OrderID|	ProductID	|Quantity	|ProductName|
|--|--|--|--|
|101|	1	|10|	Laptop|
|101|	2	|5	|Mouse|

在这个表中，ProductName依赖于ProductID而不是整个复合主键（OrderID + ProductID），这违反了第二范式。

解决方法：将表拆分为两个表，使得每个非主属性完全依赖于主键。

转换后：

OrderDetail 表：

|OrderID|	ProductID	|Quantity|
|--|--|--|
|101|	1	|10|
|101|	2	|5 |

Product 表：

|ProductID	|ProductName |
|--|--|
|1	|Laptop|
|2	|Mouse |

**3.第三范式（3NF）**

要求：在满足第二范式的基础上，表中的非主属性不应相互依赖，即任何非主属性都不依赖于其他非主属性。

示例：

假设有一张表 Employee：

|EmployeeID	|Name	|DepartmentID	|DepartmentName|
|--|--|--|--|
|1	|John	|101	|HR|
|2	|Jane	|102	|IT|

在这个表中，DepartmentName依赖于DepartmentID，而DepartmentID又依赖于EmployeeID，因此DepartmentName间接依赖于主键EmployeeID，这违反了第三范式。

解决方法：将表进一步拆分。

转换后：

Employee 表：

|EmployeeID	|Name	|DepartmentID|
|--|--|--|
|1	|John	|101|
|2	|Jane	|102|

Department 表：

|DepartmentID	|DepartmentName|
|--|--|
|101	|HR|
|102	|IT|

## 你对binlog日志和redolog日志了解吗？解释以下这两个日志的作用以及两阶段提交

**Binlog日志**

作用：

- 复制：Binlog（Binary Log）是MySQL的二进制日志文件，主要用于数据库复制（replication）。它记录了对数据库执行的所有修改操作（如INSERT、UPDATE、DELETE），以便在主从复制中从库可以重放这些操作，从而保持与主库的一致性。
- 数据恢复：在灾难恢复时，可以通过重放Binlog日志来恢复数据。备份恢复后，可以使用Binlog日志将数据库状态恢复到特定时间点，确保数据完整性和一致性。

**Redo日志**

作用：

- 数据持久化：Redo Log是InnoDB存储引擎的重做日志，用于记录事务的修改操作。这些操作会首先写入Redo Log，然后再写入数据文件。即使在系统崩溃时，也可以通过Redo Log将未完成的事务重做，从而保证数据的持久性。
- 性能优化：由于Redo Log采用顺序写入的方式，相对于随机写入的磁盘操作速度更快。这种方式提高了数据库的写入性能，因为修改操作可以先写入Redo Log，再批量刷新到数据文件中。

**两阶段提交（Two-Phase Commit）**

两阶段提交是用来保证事务在分布式系统或多个存储引擎之间的一致性的方法。MySQL使用两阶段提交来协调Binlog和Redo Log的写入，以确保在系统崩溃后，数据仍然保持一致。两阶段提交过程如下：

1.预提交阶段（Prepare Phase）：

- 事务执行过程中，所有的修改操作首先写入Redo Log的缓存区，但此时并不会提交。
- Redo Log的状态设置为准备提交（prepare）。
- 同时，事务的修改操作记录在Binlog缓存中，但不立即写入磁盘。

2.提交阶段（Commit Phase）：

- 确认所有参与的存储引擎（或分布式系统的节点）都准备好提交。
- 将Binlog缓存中的日志刷新到磁盘，确保Binlog记录持久化。
- 将Redo Log的状态从准备提交修改为已提交，并刷新到磁盘，完成实际的数据提交操作。

两阶段提交的作用

两阶段提交的主要作用是保证数据的一致性和持久性。通过在两个独立的日志系统（Binlog和Redo Log）之间协调提交操作，可以确保即使在系统崩溃的情况下，也能通过重放日志恢复数据，从而保持数据库的一致性。具体来说：

- 数据一致性：两阶段提交确保了在Binlog和Redo Log之间的原子性操作，即要么两者都成功，要么都失败，从而防止数据不一致的情况。
- 持久性保证：通过先将Redo Log写入磁盘，再写入Binlog，保证了在系统崩溃后可以通过Redo Log进行恢复，而不会丢失数据。
- 
这种机制在数据库系统中非常重要，因为它有效地解决了数据在分布式系统或多存储引擎环境中的一致性问题。


## 列举MySQL的四个隔离级别，并解释每个级别的区别以及可能产生的问题

MySQL 的事务隔离级别定义了事务之间的可见性和一致性，决定了在并发环境中事务的行为。MySQL 支持四种标准的隔离级别，每种级别在数据一致性和并发性之间有所权衡。以下是这四个隔离级别的详细解释以及它们可能产生的问题：

**1.读未提交（READ UNCOMMITTED）**

描述：

- 这是最低的隔离级别。在这个级别下，一个事务可以读取其他事务未提交的数据。

可能产生的问题：

- 脏读（Dirty Read）：事务 A 修改了数据但还未提交，事务 B 可以读取到这些未提交的数据。若事务 A 回滚，事务 B 读取到的数据就是无效的。

适用场景：

- 对数据一致性要求不高，且需要最大限度的并发性。例如，日志记录或缓存数据的应用场景。

**2.读已提交（READ COMMITTED）**

描述：

- 在这个隔离级别下，一个事务只能读取其他事务已提交的数据。即使其他事务已经提交，事务在读取数据时也不能读取到其他事务尚未提交的数据。

可能产生的问题：

- 不可重复读（Non-repeatable Read）：事务 A 在执行某个查询时读取了一些数据，随后事务 B 对这些数据进行了修改并提交。事务 A 再次执行相同的查询时会得到不同的结果。

适用场景：

- 数据一致性要求较高但仍需保持较高的并发性。适用于对数据读操作一致性有一定要求的场景。

**3.可重复读（REPEATABLE READ）**

描述：

- 在这个隔离级别下，事务在开始后读取的数据在事务期间内不会被其他事务修改，保证了每次查询的数据都是一致的。

可能产生的问题：

- 幻读（Phantom Read）：事务 A 执行一个范围查询时读取到的数据在事务 A 内部是稳定的。但如果事务 B 在事务 A 执行期间插入或删除了数据，这会导致事务 A 再次执行相同的查询时发现结果集有所不同。

适用场景：

- 需要保证在事务内对数据的读操作具有一致性，适用于大多数需要确保读取数据一致性的业务逻辑。

**4.串行化（SERIALIZABLE）**

描述：

- 这是最高的隔离级别，事务完全隔离。事务被强制序列化执行，即事务之间没有任何交叉，确保数据的一致性。

可能产生的问题：

- 性能开销：由于事务之间完全隔离，可能会导致事务执行的性能开销显著增加，特别是在高并发环境中。

适用场景：

- 数据一致性要求极高的场景，如金融交易等关键业务流程。适用于对数据完整性和一致性要求严格的应用场景。

**总结**
- 读未提交（READ UNCOMMITTED）：最低的隔离级别，可能会产生脏读。
- 读已提交（READ COMMITTED）：避免了脏读，但可能会出现不可重复读。
- 可重复读（REPEATABLE READ）：避免了脏读和不可重复读，但可能会出现幻读。
- 串行化（SERIALIZABLE）：最高的隔离级别，避免了脏读、不可重复读和幻读，但可能会导致性能降低。
根据实际的业务需求，可以选择适当的隔离级别来平衡数据一致性和系统性能。

## MySQL可重复读完全解决了幻读问题吗？

MySQL InnoDB引擎的默认隔离级别是可重复读， 根据不同的查询方式，分别提出了避免幻读的方案：
- 针对**快照读**， 通过MVCC方式解决
- 针对**当前读**， 通过next-key lock(记录锁+间隙锁)方式解决了幻读。

但是，可重复读不能彻底解决幻读，但是可以很大程度上避免幻读发生。例如事务A更新了一条事务B插入的记录，那么事务A前后两次查询到的记录条目就不一样了，所以就会发生幻读。
