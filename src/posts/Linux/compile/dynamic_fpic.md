---
category: 
- 编译原理
- Linux
- ELF文件
---


# 地址无关代码fPIC

- 1.模块内部的函数调用、跳转
- 2.模块内部的数据访问，例如本模块中定义的全局变量
- 3.模块外部的函数调用、跳转
- 4.模块外部的数据访问，例如访问其他模块中定义的全局变量

```c
static int a;
extern int b;
extern void ext();

void bar()
{
    a = 1;//类型2
    b = 2;//类型4
}

void foo()
{
    bar()；//类型1
    ext(); //类型3
}
```


## 类型1 模块内部调用或跳转

第一种场景是最为简单的。因为被调用的函数和调用者在同一个模块。因为它们之间的相对位置是固定的，所以这种情况比较简单。

对于现在的系统来讲，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用， 所以对于这种指令是不需要重定位的。


```c
8048344 <bar>:
8048344:  55       push %ebp
8048345:  89 e5    mov %esp, %ebp
8048347:  5d       pop %ebp
8048348:  c3       ret
8048349: <foo>:
...
8048357: e8 e8 ff ff ff   call 8048344 <bar>
804835c: b8 00 00 00 00   mov $0x0, %eax
```

foo中对bar的调用实际上是一条相对地址的调用指令， ```e8 e8 ff ff ff```。

这条指令中的后4个字节是目的地址相对于当前指令的吓一跳指令的偏移。

当前指令的下一条指令是```b8 00 00 00 00```，其地址是0x804835c, ```e8 ff ff ff```是-24的补码形式， 因此bar的位置在```0x804835c-24 = 0x8048344```。那么只要bar和foo的相对位置不变。这条指令是地址无关的。


