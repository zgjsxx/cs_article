---
category: 
- 编译原理
- Linux
- ELF文件
---

# Linux中的SO-NAME与动态库的版本

由于动态库有着诸多优点，其在程序中的运用非常广泛。现代的系统中一般存在大量的动态库。如何组织管理好这些动态库是一个非常重要的问题。Linux系统对于共享库的管理有一套很成熟的体系，这对于开发者而言进行程序的维护升级带来了方便。本文将对于Linux系统对于动态库的管理体系进行介绍。

# 共享库的兼容性问题

对于一个库而言，开发者会不停地更新共享库的版本，修复一些问题，增加库的功能以及对性能的改进等等。由于共享库的特性，应用程序的共享库和应用程序本身可以独立开发和更新。例如Hello_World程序依赖于一个动态库libhello.so。当libhello.so的开发者开发出新的版本后，理论上只需要使用新的libhello.so去替换旧的版本就可以。

但是现实中确远比这个复杂的多。因为动态库的改动可能包含增加/删除/修改三种类型。因此动态库的更新总体可以划分为两大类：

- 兼容更新。 动态库的更新只是在前一个版本的基础上增加了一些内容。原有的接口都保持不变。
- 不兼容更新。动态库修改了原有的接口或者删除了一些接口，使用该库的接口的程序可能不能正常运行。

这里的兼容性是指ABI（application binary interface）层面, 即二进制接口层面的兼容性。

对于一个c程序而言，兼容性可以被更加细分为下表中的内容：

|更改类型|兼容性|
|--|--|
|往动态库libhello.so中添加一个导出符号hello2|兼容|
|删除动态库libfoo.so中的原有导出符号hello|不兼容|
|将libhello.so给一个导出方法添加了一个参数， 例如从hello(int a)变成了hello(int a, int b)|不兼容|
|删除了一个导出函数的一个参数， 例如从hello(int a， int b)变成了hello(int a)|不兼容|
|修改了一个结构体的类型(长度，内容，成员类型)， 而该接口体在导出函数的接口定义上或者全局变量上，例如hello(struct World)接口， 给World结构体添加了一个新的成员|不兼容|
|修改一个导出函数中的内部bug，优化性能等等，但是没有修改接口定义，功能，行为等等|兼容|
|修改一个导出函数中的内部bug，优化性能等等，同时修改了接口定义，功能，行为等等|不兼容|

对于c++而言， ABI的兼容性问题更为严重一些。C++在语法上支持一些高级特性，例如模板、多重继承等。这些特性对于ABI的兼容性而言简直是一种灾难。

# 共享库的版本

因为动态库存在着兼容性问题，一种解决版本就是引入版本号以对动态库进行管理。

Linux中经典的动态库的命名规则如下所示：

libname.so.x.y.z

最前面使用lib，中间是库的名字和后缀".so",最后面跟着的是三个数字组成的版本号。"x"代表主版本号， "y"代表次版本号， "z"表示发布版本号。三个版本号的含义不一样。

**主版本号**表示库的重大升级，不同主版本号的库之间是不兼容的。依赖于旧的主版本号的程序需要改动相应的部分，并且重新编译，才可以使用新的共享库中运行。

**次版本号**表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。

**发布版本号**表示库的一些错误、性能的改进等，并不添加任何新的接口，也不对接口进行修改。

https://lovewubo.github.io/shared_library